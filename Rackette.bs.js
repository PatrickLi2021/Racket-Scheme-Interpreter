// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Read$Rackette = require("./Read.bs.js");
var CS17SetupRackette$Rackette = require("./CS17SetupRackette.bs.js");

function listToString(alos) {
  if (!alos) {
    return "";
  }
  var tl = alos.tl;
  var hd = alos.hd;
  if (tl) {
    return hd + (" " + listToString(tl));
  } else {
    return hd;
  }
}

var extendEnv = List.append;

function stringOfValue(vl) {
  switch (vl.TAG | 0) {
    case /* NumV */0 :
        return String(vl._0);
    case /* BoolV */1 :
        return Pervasives.string_of_bool(vl._0);
    case /* ListV */2 :
        var match = vl._0;
        if (match) {
          return "(list " + (listToString(List.map(stringOfValue, {
                            hd: match.hd,
                            tl: match.tl
                          })) + ")");
        } else {
          return "(list)";
        }
    case /* BuiltinV */3 :
        return "builtin: " + vl._0.bName;
    case /* ClosureV */4 :
        return "<User-defined procedure>";
    
  }
}

function plus(alon) {
  if (!alon) {
    return Pervasives.failwith("Error: + expects 2 arguments, but found none");
  }
  var arg1 = alon.hd;
  if (arg1.TAG === /* NumV */0) {
    var match = alon.tl;
    if (!match) {
      return Pervasives.failwith("Error: + expects 2 arguments, but found only 1");
    }
    var arg2 = match.hd;
    if (arg2.TAG === /* NumV */0) {
      if (!match.tl) {
        return {
                TAG: /* NumV */0,
                _0: arg1._0 + arg2._0 | 0
              };
      }
      
    } else if (!match.tl) {
      return Pervasives.failwith("Error: Second argument was not a number");
    }
    
  } else {
    var match$1 = alon.tl;
    if (!match$1) {
      return Pervasives.failwith("Error: + expects 2 number arguments, did not find them");
    }
    if (match$1.hd.TAG !== /* NumV */0) {
      return Pervasives.failwith("Error: + expects 2 number arguments, did not find them");
    }
    if (!match$1.tl) {
      return Pervasives.failwith("Error: First argument was not a number");
    }
    
  }
  if (arg1.TAG === /* NumV */0 && alon.tl.hd.TAG === /* NumV */0) {
    return Pervasives.failwith("Error: + expects only 2 arguments, but found more than 2");
  } else {
    return Pervasives.failwith("Error: + expects 2 number arguments, did not find them");
  }
}

function minus(alon) {
  if (!alon) {
    return Pervasives.failwith("Error: - expects 2 arguments, but found none");
  }
  var arg1 = alon.hd;
  if (arg1.TAG === /* NumV */0) {
    var match = alon.tl;
    if (!match) {
      return Pervasives.failwith("Error: - expects 2 arguments, but found only 1");
    }
    var arg2 = match.hd;
    if (arg2.TAG === /* NumV */0) {
      if (!match.tl) {
        return {
                TAG: /* NumV */0,
                _0: arg1._0 - arg2._0 | 0
              };
      }
      
    } else if (!match.tl) {
      return Pervasives.failwith("Error: Second argument was not a number");
    }
    
  } else {
    var match$1 = alon.tl;
    if (!match$1) {
      return Pervasives.failwith("Error: - expects 2 number arguments, did not find them");
    }
    if (match$1.hd.TAG !== /* NumV */0) {
      return Pervasives.failwith("Error: - expects 2 number arguments, did not find them");
    }
    if (!match$1.tl) {
      return Pervasives.failwith("Error: First argument was not a number");
    }
    
  }
  if (arg1.TAG === /* NumV */0 && alon.tl.hd.TAG === /* NumV */0) {
    return Pervasives.failwith("Error: - expects only 2 arguments, but found more than 2");
  } else {
    return Pervasives.failwith("Error: - expects 2 number arguments, did not find them");
  }
}

function mult(alon) {
  if (!alon) {
    return Pervasives.failwith("Error: * expects 2 arguments, but found none");
  }
  var arg1 = alon.hd;
  if (arg1.TAG === /* NumV */0) {
    var match = alon.tl;
    if (!match) {
      return Pervasives.failwith("Error: * expects 2 arguments, but found only 1");
    }
    var arg2 = match.hd;
    if (arg2.TAG === /* NumV */0) {
      if (!match.tl) {
        return {
                TAG: /* NumV */0,
                _0: Math.imul(arg1._0, arg2._0)
              };
      }
      
    } else if (!match.tl) {
      return Pervasives.failwith("Error: Second argument was not a number");
    }
    
  } else {
    var match$1 = alon.tl;
    if (!match$1) {
      return Pervasives.failwith("Error: * expects 2 number arguments, did not find them");
    }
    if (match$1.hd.TAG !== /* NumV */0) {
      return Pervasives.failwith("Error: * expects 2 number arguments, did not find them");
    }
    if (!match$1.tl) {
      return Pervasives.failwith("Error: First argument was not a number");
    }
    
  }
  if (arg1.TAG === /* NumV */0 && alon.tl.hd.TAG === /* NumV */0) {
    return Pervasives.failwith("Error: * expects only 2 arguments, but found more than 2");
  } else {
    return Pervasives.failwith("Error: * expects 2 number arguments, did not find them");
  }
}

function divide(alon) {
  if (!alon) {
    return Pervasives.failwith("Error: / expects 2 arguments, but found none");
  }
  var arg1 = alon.hd;
  if (arg1.TAG === /* NumV */0) {
    var match = alon.tl;
    if (!match) {
      return Pervasives.failwith("Error: / expects 2 arguments, but found only 1");
    }
    var arg2 = match.hd;
    if (arg2.TAG === /* NumV */0) {
      var arg2$1 = arg2._0;
      if (arg2$1 !== 0) {
        if (!match.tl) {
          return {
                  TAG: /* NumV */0,
                  _0: Caml_int32.div(arg1._0, arg2$1)
                };
        }
        
      } else if (!match.tl) {
        return Pervasives.failwith("Error: division by 0");
      }
      
    } else if (!match.tl) {
      return Pervasives.failwith("Error: Second argument was not a number");
    }
    
  } else {
    var match$1 = alon.tl;
    if (!match$1) {
      return Pervasives.failwith("Error: / expects 2 number arguments, did not find them");
    }
    if (match$1.hd.TAG !== /* NumV */0) {
      return Pervasives.failwith("Error: / expects 2 number arguments, did not find them");
    }
    if (!match$1.tl) {
      return Pervasives.failwith("Error: First argument was not a number");
    }
    
  }
  if (arg1.TAG === /* NumV */0 && alon.tl.hd.TAG === /* NumV */0) {
    return Pervasives.failwith("Error: / expects only 2 arguments, but found more than 2");
  } else {
    return Pervasives.failwith("Error: / expects 2 number arguments, did not find them");
  }
}

function remainder(alon) {
  if (!alon) {
    return Pervasives.failwith("Error: remainder expects 2 arguments, but found none");
  }
  var arg1 = alon.hd;
  if (arg1.TAG === /* NumV */0) {
    var match = alon.tl;
    if (!match) {
      return Pervasives.failwith("Error: remainder expects 2 arguments, but found only 1");
    }
    var arg2 = match.hd;
    if (arg2.TAG === /* NumV */0) {
      if (!match.tl) {
        return {
                TAG: /* NumV */0,
                _0: Caml_int32.mod_(arg1._0, arg2._0)
              };
      }
      
    } else if (!match.tl) {
      return Pervasives.failwith("Error: Second argument was not a number");
    }
    
  } else {
    var match$1 = alon.tl;
    if (!match$1) {
      return Pervasives.failwith("Error: remainder expects 2 number arguments, did not find them");
    }
    if (match$1.hd.TAG !== /* NumV */0) {
      return Pervasives.failwith("Error: remainder expects 2 number arguments, did not find them");
    }
    if (!match$1.tl) {
      return Pervasives.failwith("Error: First argument was not a number");
    }
    
  }
  if (arg1.TAG === /* NumV */0 && alon.tl.hd.TAG === /* NumV */0) {
    return Pervasives.failwith("Error: remainder expects only 2 arguments, but found more than 2");
  } else {
    return Pervasives.failwith("Error: remainder expects 2 number arguments, did not find them");
  }
}

function equal(alon) {
  if (!alon) {
    return Pervasives.failwith("Error: = expects 2 arguments, but found none");
  }
  var arg1 = alon.hd;
  if (arg1.TAG === /* NumV */0) {
    var match = alon.tl;
    if (!match) {
      return Pervasives.failwith("Error: = expects 2 arguments, but found only 1");
    }
    var arg2 = match.hd;
    if (arg2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("Error: = expects only 2 arguments, but found more than 2");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: arg1._0 === arg2._0
              };
      }
    } else if (match.tl) {
      return Pervasives.failwith("Error: = expects only 2 arguments, but found more than 2");
    } else {
      return Pervasives.failwith("Error: Second argument was not a number");
    }
  }
  var match$1 = alon.tl;
  if (match$1) {
    if (match$1.hd.TAG === /* NumV */0) {
      if (match$1.tl) {
        return Pervasives.failwith("Error: = expects only 2 arguments, but found more than 2");
      } else {
        return Pervasives.failwith("Error: First argument was not a number");
      }
    } else if (match$1.tl) {
      return Pervasives.failwith("Error: = expects only 2 arguments, but found more than 2");
    } else {
      return Pervasives.failwith("Error: = expects 2 numbers");
    }
  } else {
    return Pervasives.failwith("Error: = expects only 2 arguments, but found more than 2");
  }
}

function lessThan(alon) {
  if (!alon) {
    return Pervasives.failwith("Error: < expects 2 arguments, but found none");
  }
  var arg1 = alon.hd;
  if (arg1.TAG === /* NumV */0) {
    var match = alon.tl;
    if (!match) {
      return Pervasives.failwith("Error: < expects 2 arguments, but found only 1");
    }
    var arg2 = match.hd;
    if (arg2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("Error: < expects only 2 arguments, but found more than 2");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: arg1._0 < arg2._0
              };
      }
    } else if (match.tl) {
      return Pervasives.failwith("Error: < expects only 2 arguments, but found more than 2");
    } else {
      return Pervasives.failwith("Error: Second argument was not a number");
    }
  }
  var match$1 = alon.tl;
  if (match$1 && match$1.hd.TAG === /* NumV */0 && !match$1.tl) {
    return Pervasives.failwith("Error: First argument was not a number");
  } else {
    return Pervasives.failwith("Error: < expects only 2 arguments, but found more than 2");
  }
}

function greaterThan(alon) {
  if (!alon) {
    return Pervasives.failwith("Error: > expects 2 arguments, but found none");
  }
  var arg1 = alon.hd;
  if (arg1.TAG === /* NumV */0) {
    var match = alon.tl;
    if (!match) {
      return Pervasives.failwith("Error: > expects 2 arguments, but found only 1");
    }
    var arg2 = match.hd;
    if (arg2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("Error: > expects only 2 arguments, but found more than 2");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: arg1._0 > arg2._0
              };
      }
    } else if (match.tl) {
      return Pervasives.failwith("Error: > expects only 2 arguments, but found more than 2");
    } else {
      return Pervasives.failwith("Error: Second argument was not a number");
    }
  }
  var match$1 = alon.tl;
  if (match$1 && match$1.hd.TAG === /* NumV */0 && !match$1.tl) {
    return Pervasives.failwith("Error: First argument was not a number");
  } else {
    return Pervasives.failwith("Error: > expects only 2 arguments, but found more than 2");
  }
}

function lessThanOrEqualTo(alon) {
  if (!alon) {
    return Pervasives.failwith("Error: <= expects 2 arguments, but found none");
  }
  var arg1 = alon.hd;
  if (arg1.TAG === /* NumV */0) {
    var match = alon.tl;
    if (!match) {
      return Pervasives.failwith("Error: <= expects 2 arguments, but found only 1");
    }
    var arg2 = match.hd;
    if (arg2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("Error: <= expects only 2 arguments, but found more than 2");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: arg1._0 <= arg2._0
              };
      }
    } else if (match.tl) {
      return Pervasives.failwith("Error: <= expects only 2 arguments, but found more than 2");
    } else {
      return Pervasives.failwith("Error: Second argument was not a number");
    }
  }
  var match$1 = alon.tl;
  if (match$1 && match$1.hd.TAG === /* NumV */0 && !match$1.tl) {
    return Pervasives.failwith("Error: First argument was not a number");
  } else {
    return Pervasives.failwith("Error: <= expects only 2 arguments, but found more than 2");
  }
}

function greaterThanOrEqualTo(alov) {
  if (!alov) {
    return Pervasives.failwith("Error: >= expects 2 arguments, but found none");
  }
  var arg1 = alov.hd;
  if (arg1.TAG === /* NumV */0) {
    var match = alov.tl;
    if (!match) {
      return Pervasives.failwith("Error: >= expects 2 arguments, but found only 1");
    }
    var arg2 = match.hd;
    if (arg2.TAG === /* NumV */0) {
      if (match.tl) {
        return Pervasives.failwith("Error: >= expects only 2 arguments, but found more than 2");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: arg1._0 >= arg2._0
              };
      }
    } else if (match.tl) {
      return Pervasives.failwith("Error: >= expects only 2 arguments, but found more than 2");
    } else {
      return Pervasives.failwith("Error: Second argument was not a number");
    }
  }
  var match$1 = alov.tl;
  if (match$1 && match$1.hd.TAG === /* NumV */0 && !match$1.tl) {
    return Pervasives.failwith("Error: First argument was not a number");
  } else {
    return Pervasives.failwith("Error: >= expects only 2 arguments, but found more than 2");
  }
}

function isEqual(alov) {
  if (!alov) {
    return Pervasives.failwith("Error: equal? expects 2 arguments, but found none");
  }
  var match = alov.tl;
  if (match) {
    if (match.tl) {
      return Pervasives.failwith("Error: equal? expects only 2 arguments, but found more than 2");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: Caml_obj.caml_equal(alov.hd, match.hd)
            };
    }
  } else {
    return Pervasives.failwith("Error: equal? expects 2 arguments, but found only 1");
  }
}

function isNumber(alov) {
  if (alov) {
    if (alov.hd.TAG === /* NumV */0) {
      if (alov.tl) {
        return Pervasives.failwith("Error: number? expects only 1 argument, but found more than 1");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (alov.tl) {
      return Pervasives.failwith("Error: number? expects only 1 argument, but found more than 1");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("Error: number? expects 1 argument, but found none");
  }
}

function isZero(alov) {
  if (!alov) {
    return Pervasives.failwith("Error: zero? expects 1 argument, but found none");
  }
  var match = alov.hd;
  if (match.TAG === /* NumV */0) {
    if (match._0 !== 0) {
      if (alov.tl) {
        return Pervasives.failwith("Error: zero? expects only 1 argument, but found more than 1");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: false
              };
      }
    } else if (alov.tl) {
      return Pervasives.failwith("Error: zero? expects only 1 argument, but found more than 1");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    }
  } else if (alov.tl) {
    return Pervasives.failwith("Error: zero? expects only 1 argument, but found more than 1");
  } else {
    return Pervasives.failwith("Error: zero? expects a number and didn't find one");
  }
}

function cons(alov) {
  if (!alov) {
    return Pervasives.failwith("Error: cons expects 2 arguments, but found none");
  }
  var match = alov.tl;
  var arg1 = alov.hd;
  if (!match) {
    return Pervasives.failwith("Error: cons expects 2 arguments, but found only 1");
  }
  var match$1 = match.hd;
  if (match$1.TAG !== /* ListV */2) {
    return Pervasives.failwith("Error: cons expects only 2 arguments, but found more than 2");
  }
  var match$2 = match$1._0;
  if (match$2) {
    if (match.tl) {
      return Pervasives.failwith("Error: cons expects only 2 arguments, but found more than 2");
    } else {
      return {
              TAG: /* ListV */2,
              _0: {
                hd: arg1,
                tl: {
                  hd: match$2.hd,
                  tl: match$2.tl
                }
              }
            };
    }
  } else if (match.tl) {
    return Pervasives.failwith("Error: cons expects only 2 arguments, but found more than 2");
  } else {
    return {
            TAG: /* ListV */2,
            _0: {
              hd: arg1,
              tl: /* [] */0
            }
          };
  }
}

function first(alov) {
  if (!alov) {
    return Pervasives.failwith("Error: first expects a non-empty list");
  }
  var match = alov.hd;
  if (match.TAG !== /* ListV */2) {
    return Pervasives.failwith("Error: first expects a non-empty list");
  }
  var match$1 = match._0;
  if (match$1 && !alov.tl) {
    return match$1.hd;
  } else {
    return Pervasives.failwith("Error: first expects a non-empty list");
  }
}

function rest(alov) {
  if (!alov) {
    return Pervasives.failwith("Error: rest expects a non-empty list");
  }
  var match = alov.hd;
  if (match.TAG !== /* ListV */2) {
    return Pervasives.failwith("Error: rest expects a non-empty list");
  }
  var match$1 = match._0;
  if (!match$1) {
    return Pervasives.failwith("Error: rest expects a non-empty list");
  }
  var tl = match$1.tl;
  if (tl) {
    if (alov.tl) {
      return Pervasives.failwith("Error: rest expects a non-empty list");
    } else {
      return {
              TAG: /* ListV */2,
              _0: tl
            };
    }
  } else if (alov.tl) {
    return Pervasives.failwith("Error: rest expects a non-empty list");
  } else {
    return {
            TAG: /* ListV */2,
            _0: /* [] */0
          };
  }
}

function isEmpty(alov) {
  if (!alov) {
    return Pervasives.failwith("Error: empty? expects a list of values as input");
  }
  var match = alov.hd;
  switch (match.TAG | 0) {
    case /* NumV */0 :
    case /* BoolV */1 :
        return Pervasives.failwith("Error: empty? expects a list of values as input");
    case /* ListV */2 :
        if (match._0 || alov.tl) {
          return {
                  TAG: /* BoolV */1,
                  _0: false
                };
        } else {
          return {
                  TAG: /* BoolV */1,
                  _0: true
                };
        }
    case /* BuiltinV */3 :
    case /* ClosureV */4 :
        return {
                TAG: /* BoolV */1,
                _0: false
              };
    
  }
}

function isCons(alov) {
  if (!alov) {
    return Pervasives.failwith("Error: cons? expects only 1 argument, but found more than 1 argument");
  }
  var match = alov.hd;
  if (match.TAG === /* ListV */2) {
    if (match._0) {
      if (alov.tl) {
        return Pervasives.failwith("Error: cons? expects only 1 argument, but found more than 1 argument");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (alov.tl) {
      return Pervasives.failwith("Error: cons? expects only 1 argument, but found more than 1 argument");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else if (alov.tl) {
    return Pervasives.failwith("Error: cons? expects only 1 argument, but found more than 1 argument");
  } else {
    return {
            TAG: /* BoolV */1,
            _0: false
          };
  }
}

function opposite(alov) {
  if (!alov) {
    return Pervasives.failwith("Error: not expects 1 argument, but found none");
  }
  var arg = alov.hd;
  switch (arg.TAG | 0) {
    case /* BoolV */1 :
        if (alov.tl) {
          return Pervasives.failwith("Error: not expects either true or false");
        } else if (arg._0 === true) {
          return {
                  TAG: /* BoolV */1,
                  _0: false
                };
        } else {
          return {
                  TAG: /* BoolV */1,
                  _0: true
                };
        }
    case /* NumV */0 :
    case /* ListV */2 :
    case /* BuiltinV */3 :
    case /* ClosureV */4 :
        return Pervasives.failwith("Error: not expects either true or false");
    
  }
}

var initialTle_0 = [
  /* Name */{
    _0: "+"
  },
  {
    TAG: /* BuiltinV */3,
    _0: {
      bName: "<builtin-proc-+",
      bProc: plus
    }
  }
];

var initialTle_1 = {
  hd: [
    /* Name */{
      _0: "-"
    },
    {
      TAG: /* BuiltinV */3,
      _0: {
        bName: "<builtin-proc--",
        bProc: minus
      }
    }
  ],
  tl: {
    hd: [
      /* Name */{
        _0: "*"
      },
      {
        TAG: /* BuiltinV */3,
        _0: {
          bName: "<builtin-proc-*",
          bProc: mult
        }
      }
    ],
    tl: {
      hd: [
        /* Name */{
          _0: "/"
        },
        {
          TAG: /* BuiltinV */3,
          _0: {
            bName: "<builtin-proc-/",
            bProc: divide
          }
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "remainder"
          },
          {
            TAG: /* BuiltinV */3,
            _0: {
              bName: "<builtin-proc-remainder",
              bProc: remainder
            }
          }
        ],
        tl: {
          hd: [
            /* Name */{
              _0: "="
            },
            {
              TAG: /* BuiltinV */3,
              _0: {
                bName: "<builtin-proc-=",
                bProc: equal
              }
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: "<"
              },
              {
                TAG: /* BuiltinV */3,
                _0: {
                  bName: "<builtin-proc-<",
                  bProc: lessThan
                }
              }
            ],
            tl: {
              hd: [
                /* Name */{
                  _0: ">"
                },
                {
                  TAG: /* BuiltinV */3,
                  _0: {
                    bName: "<builtin-proc->",
                    bProc: greaterThan
                  }
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "<="
                  },
                  {
                    TAG: /* BuiltinV */3,
                    _0: {
                      bName: "<builtin-proc-<=",
                      bProc: lessThanOrEqualTo
                    }
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: ">="
                    },
                    {
                      TAG: /* BuiltinV */3,
                      _0: {
                        bName: "<builtin-proc->=",
                        bProc: greaterThanOrEqualTo
                      }
                    }
                  ],
                  tl: {
                    hd: [
                      /* Name */{
                        _0: "equal?"
                      },
                      {
                        TAG: /* BuiltinV */3,
                        _0: {
                          bName: "<builtin-proc-equal?",
                          bProc: isEqual
                        }
                      }
                    ],
                    tl: {
                      hd: [
                        /* Name */{
                          _0: "number?"
                        },
                        {
                          TAG: /* BuiltinV */3,
                          _0: {
                            bName: "<builtin-proc-number?",
                            bProc: isNumber
                          }
                        }
                      ],
                      tl: {
                        hd: [
                          /* Name */{
                            _0: "zero?"
                          },
                          {
                            TAG: /* BuiltinV */3,
                            _0: {
                              bName: "<builtin-proc-zero?",
                              bProc: isZero
                            }
                          }
                        ],
                        tl: {
                          hd: [
                            /* Name */{
                              _0: "cons"
                            },
                            {
                              TAG: /* BuiltinV */3,
                              _0: {
                                bName: "<builtin-proc-cons",
                                bProc: cons
                              }
                            }
                          ],
                          tl: {
                            hd: [
                              /* Name */{
                                _0: "first"
                              },
                              {
                                TAG: /* BuiltinV */3,
                                _0: {
                                  bName: "<builtin-proc-first",
                                  bProc: first
                                }
                              }
                            ],
                            tl: {
                              hd: [
                                /* Name */{
                                  _0: "rest"
                                },
                                {
                                  TAG: /* BuiltinV */3,
                                  _0: {
                                    bName: "<builtin-proc-rest",
                                    bProc: rest
                                  }
                                }
                              ],
                              tl: {
                                hd: [
                                  /* Name */{
                                    _0: "empty?"
                                  },
                                  {
                                    TAG: /* BuiltinV */3,
                                    _0: {
                                      bName: "<builtin-proc-empty?",
                                      bProc: isEmpty
                                    }
                                  }
                                ],
                                tl: {
                                  hd: [
                                    /* Name */{
                                      _0: "cons?"
                                    },
                                    {
                                      TAG: /* BuiltinV */3,
                                      _0: {
                                        bName: "<builtin-proc-cons?",
                                        bProc: isCons
                                      }
                                    }
                                  ],
                                  tl: {
                                    hd: [
                                      /* Name */{
                                        _0: "not"
                                      },
                                      {
                                        TAG: /* BuiltinV */3,
                                        _0: {
                                          bName: "<builtin-proc-not",
                                          bProc: opposite
                                        }
                                      }
                                    ],
                                    tl: /* [] */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

var initialTle = {
  hd: initialTle_0,
  tl: initialTle_1
};

function parseExpression(input) {
  var parseLet = function (listcPP) {
    if (!listcPP) {
      return Pervasives.failwith("Error: let expression expects a series of bindings followed byexpression, but did not find them");
    }
    var match = listcPP.hd;
    switch (match.TAG | 0) {
      case /* NumberC */0 :
      case /* SymbolC */1 :
          return Pervasives.failwith("Error: let expression expects a series of bindings followed byexpression, but did not find them");
      case /* ListC */2 :
          var match$1 = match._0;
          if (!match$1) {
            if (listcPP.tl) {
              return Pervasives.failwith("Error: let expression expects a series of bindings followed byexpression, but did not find them");
            } else {
              return /* [] */0;
            }
          }
          var sym = match$1.hd;
          switch (sym.TAG | 0) {
            case /* SymbolC */1 :
                var match$2 = match$1.tl;
                if (!match$2) {
                  return Pervasives.failwith("Error: let expression expects a series of bindings followed byexpression, but did not find them");
                }
                if (match$2.tl) {
                  return Pervasives.failwith("Error: let expression expects a series of bindings followed byexpression, but did not find them");
                }
                var tl = listcPP.tl;
                var arg = match$2.hd;
                var sym$1 = sym._0;
                if (tl) {
                  return {
                          hd: {
                            pairName: /* Name */{
                              _0: sym$1
                            },
                            pairExpr: parseExpression(arg)
                          },
                          tl: parseLet(tl)
                        };
                } else {
                  return {
                          hd: {
                            pairName: /* Name */{
                              _0: sym$1
                            },
                            pairExpr: parseExpression(arg)
                          },
                          tl: /* [] */0
                        };
                }
            case /* NumberC */0 :
            case /* ListC */2 :
                return Pervasives.failwith("Error: let expression expects a series of bindings followed byexpression, but did not find them");
            
          }
      
    }
  };
  var parseCond = function (listcPP) {
    if (!listcPP) {
      return /* [] */0;
    }
    var match = listcPP.hd;
    switch (match.TAG | 0) {
      case /* NumberC */0 :
      case /* SymbolC */1 :
          return Pervasives.failwith("Error: Expected a clause with a question andanswer, but did not find both");
      case /* ListC */2 :
          var match$1 = match._0;
          if (!match$1) {
            return Pervasives.failwith("Error: Expected a clause with a question andanswer, but did not find both");
          }
          var match$2 = match$1.tl;
          if (!match$2) {
            return Pervasives.failwith("Error: Expected a clause with a question andanswer, but did not find both");
          }
          if (match$2.tl) {
            return Pervasives.failwith("Error: Expected a clause with a question andanswer, but did not find both");
          }
          var tl = listcPP.tl;
          var result = match$2.hd;
          var pred = match$1.hd;
          if (tl) {
            return {
                    hd: {
                      conditionExpr: parseExpression(pred),
                      resultExpr: parseExpression(result)
                    },
                    tl: parseCond(tl)
                  };
          } else {
            return {
                    hd: {
                      conditionExpr: parseExpression(pred),
                      resultExpr: parseExpression(result)
                    },
                    tl: /* [] */0
                  };
          }
      
    }
  };
  var parseLambda = function (listcPP) {
    if (!listcPP) {
      return /* [] */0;
    }
    var sym = listcPP.hd;
    switch (sym.TAG | 0) {
      case /* SymbolC */1 :
          var tl = listcPP.tl;
          var sym$1 = sym._0;
          if (tl) {
            return {
                    hd: /* Name */{
                      _0: sym$1
                    },
                    tl: parseLambda(tl)
                  };
          } else {
            return {
                    hd: /* Name */{
                      _0: sym$1
                    },
                    tl: /* [] */0
                  };
          }
      case /* NumberC */0 :
      case /* ListC */2 :
          return Pervasives.failwith("Error: Lambda expression expected a list offormal arguments, but did not find them");
      
    }
  };
  switch (input.TAG | 0) {
    case /* NumberC */0 :
        return {
                TAG: /* NumE */0,
                _0: input._0
              };
    case /* SymbolC */1 :
        var sym = input._0;
        switch (sym) {
          case "empty" :
              return /* EmptyE */0;
          case "false" :
              return {
                      TAG: /* BoolE */1,
                      _0: false
                    };
          case "true" :
              return {
                      TAG: /* BoolE */1,
                      _0: true
                    };
          default:
            switch (sym) {
              case "and" :
              case "cond" :
              case "define" :
              case "if" :
              case "lambda" :
              case "let" :
              case "or" :
                  return Pervasives.failwith("Error: reserved keyword");
              default:
                return {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: sym
                        }
                      };
            }
        }
    case /* ListC */2 :
        var alod = input._0;
        if (!alod) {
          return Pervasives.failwith("Error: empty set of parentheses is not a valid expression");
        }
        var match = alod.hd;
        switch (match.TAG | 0) {
          case /* NumberC */0 :
              return {
                      TAG: /* ApplicationE */9,
                      _0: List.map(parseExpression, alod)
                    };
          case /* SymbolC */1 :
              switch (match._0) {
                case "and" :
                    var match$1 = alod.tl;
                    if (!match$1) {
                      return Pervasives.failwith("Error: and did not have correct number of arguments");
                    }
                    var match$2 = match$1.tl;
                    if (match$2 && !match$2.tl) {
                      return {
                              TAG: /* AndE */3,
                              _0: parseExpression(match$1.hd),
                              _1: parseExpression(match$2.hd)
                            };
                    } else {
                      return Pervasives.failwith("Error: and did not have correct number of arguments");
                    }
                case "cond" :
                    var match$3 = alod.tl;
                    if (!match$3) {
                      return Pervasives.failwith("Error: cond expected arguments after, but did not find any");
                    }
                    var match$4 = match$3.hd;
                    switch (match$4.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return {
                                  TAG: /* ApplicationE */9,
                                  _0: List.map(parseExpression, alod)
                                };
                      case /* ListC */2 :
                          var match$5 = match$4._0;
                          if (!match$5) {
                            return {
                                    TAG: /* ApplicationE */9,
                                    _0: List.map(parseExpression, alod)
                                  };
                          }
                          var match$6 = match$5.tl;
                          if (match$6 && !match$6.tl) {
                            return {
                                    TAG: /* CondE */6,
                                    _0: {
                                      hd: {
                                        conditionExpr: parseExpression(match$5.hd),
                                        resultExpr: parseExpression(match$6.hd)
                                      },
                                      tl: parseCond(match$3.tl)
                                    }
                                  };
                          } else {
                            return {
                                    TAG: /* ApplicationE */9,
                                    _0: List.map(parseExpression, alod)
                                  };
                          }
                      
                    }
                case "if" :
                    var match$7 = alod.tl;
                    if (!match$7) {
                      return Pervasives.failwith("Error: if did not have correct number of arguments");
                    }
                    var match$8 = match$7.tl;
                    if (!match$8) {
                      return Pervasives.failwith("Error: if did not have correct number of arguments");
                    }
                    var match$9 = match$8.tl;
                    if (match$9 && !match$9.tl) {
                      return {
                              TAG: /* IfE */5,
                              _0: {
                                boolExpr: parseExpression(match$7.hd),
                                trueExpr: parseExpression(match$8.hd),
                                falseExpr: parseExpression(match$9.hd)
                              }
                            };
                    } else {
                      return Pervasives.failwith("Error: if did not have correct number of arguments");
                    }
                case "lambda" :
                    var match$10 = alod.tl;
                    if (!match$10) {
                      return Pervasives.failwith("Error: lambda expression did not have correct number of arguments");
                    }
                    var alod$1 = match$10.hd;
                    switch (alod$1.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return Pervasives.failwith("Error: lambda expression did not have correct number of arguments");
                      case /* ListC */2 :
                          var match$11 = match$10.tl;
                          if (match$11 && !match$11.tl) {
                            return {
                                    TAG: /* LambdaE */7,
                                    _0: {
                                      nameList: parseLambda(alod$1._0),
                                      lambdaBody: parseExpression(match$11.hd)
                                    }
                                  };
                          } else {
                            return Pervasives.failwith("Error: lambda expression did not have correct number of arguments");
                          }
                      
                    }
                case "let" :
                    var match$12 = alod.tl;
                    if (!match$12) {
                      return Pervasives.failwith("Error: let expects a list of pre-bindings and expressions, but did not find them");
                    }
                    var arg1 = match$12.hd;
                    switch (arg1.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return {
                                  TAG: /* ApplicationE */9,
                                  _0: List.map(parseExpression, alod)
                                };
                      case /* ListC */2 :
                          var arg1$1 = arg1._0;
                          if (arg1$1) {
                            var match$13 = match$12.tl;
                            if (match$13 && !match$13.tl) {
                              return {
                                      TAG: /* LetE */8,
                                      _0: {
                                        letPairs: parseLet(arg1$1),
                                        letBody: parseExpression(match$13.hd)
                                      }
                                    };
                            } else {
                              return {
                                      TAG: /* ApplicationE */9,
                                      _0: List.map(parseExpression, alod)
                                    };
                            }
                          }
                          var match$14 = match$12.tl;
                          if (match$14 && !match$14.tl) {
                            return {
                                    TAG: /* LetE */8,
                                    _0: {
                                      letPairs: /* [] */0,
                                      letBody: parseExpression(match$14.hd)
                                    }
                                  };
                          } else {
                            return {
                                    TAG: /* ApplicationE */9,
                                    _0: List.map(parseExpression, alod)
                                  };
                          }
                      
                    }
                case "or" :
                    var match$15 = alod.tl;
                    if (!match$15) {
                      return Pervasives.failwith("Error: or did not have correct number of arguments");
                    }
                    var match$16 = match$15.tl;
                    if (match$16 && !match$16.tl) {
                      return {
                              TAG: /* OrE */4,
                              _0: parseExpression(match$15.hd),
                              _1: parseExpression(match$16.hd)
                            };
                    } else {
                      return Pervasives.failwith("Error: or did not have correct number of arguments");
                    }
                default:
                  return {
                          TAG: /* ApplicationE */9,
                          _0: List.map(parseExpression, alod)
                        };
              }
          case /* ListC */2 :
              var match$17 = match._0;
              if (!match$17) {
                return {
                        TAG: /* ApplicationE */9,
                        _0: List.map(parseExpression, alod)
                      };
              }
              var match$18 = match$17.hd;
              switch (match$18.TAG | 0) {
                case /* SymbolC */1 :
                    if (match$18._0 !== "lambda") {
                      return {
                              TAG: /* ApplicationE */9,
                              _0: List.map(parseExpression, alod)
                            };
                    }
                    var match$19 = match$17.tl;
                    if (!match$19) {
                      return {
                              TAG: /* ApplicationE */9,
                              _0: List.map(parseExpression, alod)
                            };
                    }
                    var match$20 = match$19.hd;
                    switch (match$20.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return {
                                  TAG: /* ApplicationE */9,
                                  _0: List.map(parseExpression, alod)
                                };
                      case /* ListC */2 :
                          var match$21 = match$20._0;
                          if (!match$21) {
                            return {
                                    TAG: /* ApplicationE */9,
                                    _0: List.map(parseExpression, alod)
                                  };
                          }
                          var match$22 = match$19.tl;
                          if (match$22 && !match$22.tl) {
                            return {
                                    TAG: /* ApplicationE */9,
                                    _0: {
                                      hd: {
                                        TAG: /* LambdaE */7,
                                        _0: {
                                          nameList: parseLambda({
                                                hd: match$21.hd,
                                                tl: match$21.tl
                                              }),
                                          lambdaBody: parseExpression(match$22.hd)
                                        }
                                      },
                                      tl: List.map(parseExpression, alod.tl)
                                    }
                                  };
                          } else {
                            return {
                                    TAG: /* ApplicationE */9,
                                    _0: List.map(parseExpression, alod)
                                  };
                          }
                      
                    }
                case /* NumberC */0 :
                case /* ListC */2 :
                    return {
                            TAG: /* ApplicationE */9,
                            _0: List.map(parseExpression, alod)
                          };
                
              }
          
        }
    
  }
}

function parseDefinition(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return Pervasives.failwith("Error: Expected a variable name");
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return Pervasives.failwith("Error: Expected a variable name");
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 === "define") {
                var match$2 = match.tl;
                if (!match$2) {
                  return Pervasives.failwith("Error: Expected a variable name");
                }
                var sym = match$2.hd;
                switch (sym.TAG | 0) {
                  case /* SymbolC */1 :
                      var match$3 = match$2.tl;
                      if (!match$3) {
                        return Pervasives.failwith("Error: Expected a variable name");
                      }
                      if (match$3.tl) {
                        return Pervasives.failwith("Error: Expected a variable name");
                      }
                      var sym$1 = sym._0;
                      switch (sym$1) {
                        case "and" :
                        case "cond" :
                        case "define" :
                        case "empty" :
                        case "false" :
                        case "if" :
                        case "lambda" :
                        case "let" :
                        case "or" :
                        case "true" :
                            return Pervasives.failwith("Error: Cannot redefine a keyword");
                        default:
                          return [
                                  /* Name */{
                                    _0: sym$1
                                  },
                                  parseExpression(match$3.hd)
                                ];
                      }
                  case /* NumberC */0 :
                  case /* ListC */2 :
                      break;
                  
                }
              }
              break;
          case /* NumberC */0 :
          case /* ListC */2 :
              break;
          
        }
        var match$4 = match.tl;
        if (!match$4) {
          return Pervasives.failwith("Error: Expected a variable name");
        }
        switch (match$4.hd.TAG | 0) {
          case /* NumberC */0 :
              return Pervasives.failwith("Error: Expected a variable name, found a number");
          case /* SymbolC */1 :
              return Pervasives.failwith("Error: Expected a variable name");
          case /* ListC */2 :
              return Pervasives.failwith("Error: Expected a variable name, found an expression");
          
        }
        break;
    
  }
}

function parsePiece(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return {
                TAG: /* Expression */1,
                _0: parseExpression(input)
              };
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return {
                  TAG: /* Expression */1,
                  _0: parseExpression(input)
                };
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 === "define") {
                return {
                        TAG: /* Definition */0,
                        _0: parseDefinition(input)
                      };
              } else {
                return {
                        TAG: /* Expression */1,
                        _0: parseExpression(input)
                      };
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return {
                      TAG: /* Expression */1,
                      _0: parseExpression(input)
                    };
          
        }
    
  }
}

function parse(input) {
  return List.map(parsePiece, input);
}

function lookup(_env, n) {
  while(true) {
    var env = _env;
    if (!env) {
      return ;
    }
    var match = env.hd;
    if (Caml_obj.caml_equal(n, match[0])) {
      return match[1];
    }
    _env = env.tl;
    continue ;
  };
}

function uniqueListP(alon) {
  if (alon) {
    return !List.mem(alon.hd, alon.tl);
  } else {
    return true;
  }
}

function addBindingsToClosure(alon, alov) {
  if (alon) {
    if (alov) {
      if (alon) {
        if (uniqueListP(alon) === true) {
          return {
                  hd: [
                    alon.hd,
                    alov.hd
                  ],
                  tl: addBindingsToClosure(alon.tl, alov.tl)
                };
        } else {
          return Pervasives.failwith("Error: Found a variable that is used more than once");
        }
      } else {
        return /* [] */0;
      }
    } else {
      return Pervasives.failwith("Error: Number of of formal arguments doesn't match");
    }
  } else if (alov) {
    return Pervasives.failwith("Error: Number of of formal arguments doesn't match");
  } else {
    return /* [] */0;
  }
}

function addBinding(env, bnd) {
  return {
          hd: bnd,
          tl: env
        };
}

function $$eval(tle, _env, _expr) {
  while(true) {
    var expr = _expr;
    var env = _env;
    var addBindingsForLet = (function(env){
    return function addBindingsForLet(_letEnv, _alop) {
      while(true) {
        var alop = _alop;
        var letEnv = _letEnv;
        if (!alop) {
          return /* [] */0;
        }
        var tl = alop.tl;
        var match = alop.hd;
        var expr = match.pairExpr;
        var n = match.pairName;
        if (!tl) {
          if (lookup(letEnv, n) === undefined) {
            return {
                    hd: [
                      n,
                      $$eval(tle, env, expr)
                    ],
                    tl: letEnv
                  };
          } else {
            return Pervasives.failwith("Error: A variable name was defined locally more than once");
          }
        }
        if (lookup(letEnv, n) !== undefined) {
          return Pervasives.failwith("Error: A variable name was defined locally more than once");
        }
        _alop = tl;
        _letEnv = {
          hd: [
            n,
            $$eval(tle, env, expr)
          ],
          tl: letEnv
        };
        continue ;
      };
    }
    }(env));
    var evalArgs = function (tle, env, aloe) {
      if (aloe) {
        return {
                hd: $$eval(tle, env, aloe.hd),
                tl: evalArgs(tle, env, aloe.tl)
              };
      } else {
        return /* [] */0;
      }
    };
    if (typeof expr === "number") {
      return {
              TAG: /* ListV */2,
              _0: /* [] */0
            };
    }
    switch (expr.TAG | 0) {
      case /* NumE */0 :
          return {
                  TAG: /* NumV */0,
                  _0: expr._0
                };
      case /* BoolE */1 :
          return {
                  TAG: /* BoolV */1,
                  _0: expr._0
                };
      case /* NameE */2 :
          var v = lookup(List.append(env, tle), /* Name */{
                _0: expr._0._0
              });
          if (v !== undefined) {
            return v;
          } else {
            return Pervasives.failwith("Error: This variable/function is not defined");
          }
      case /* AndE */3 :
          var match = $$eval(tle, env, expr._0);
          if (match.TAG !== /* BoolV */1) {
            return Pervasives.failwith("Error: and expression has incorrect arguments");
          }
          if (!match._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: false
                  };
          }
          var match$1 = $$eval(tle, env, expr._1);
          if (match$1.TAG === /* BoolV */1) {
            if (match$1._0) {
              return {
                      TAG: /* BoolV */1,
                      _0: true
                    };
            } else {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
          } else {
            return Pervasives.failwith("Error: and expression has incorrect arguments");
          }
      case /* OrE */4 :
          var match$2 = $$eval(tle, env, expr._0);
          if (match$2.TAG !== /* BoolV */1) {
            return Pervasives.failwith("Error: or expression has incorrect arguments");
          }
          if (match$2._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: true
                  };
          }
          var match$3 = $$eval(tle, env, expr._1);
          if (match$3.TAG === /* BoolV */1) {
            if (match$3._0) {
              return {
                      TAG: /* BoolV */1,
                      _0: true
                    };
            } else {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
          } else {
            return Pervasives.failwith("Error: or expression has incorrect arguments");
          }
      case /* IfE */5 :
          var match$4 = expr._0;
          var pred = match$4.boolExpr;
          var match$5 = $$eval(tle, env, pred);
          if (match$5.TAG !== /* BoolV */1) {
            return Pervasives.failwith("Error: if question result was not true or false");
          }
          if (Caml_obj.caml_equal($$eval(tle, env, pred), {
                  TAG: /* BoolV */1,
                  _0: true
                })) {
            _expr = match$4.trueExpr;
            continue ;
          }
          _expr = match$4.falseExpr;
          continue ;
      case /* CondE */6 :
          var listOfCondData = expr._0;
          if (!listOfCondData) {
            return Pervasives.failwith("Error: cond expression not found/formatted correctly");
          }
          var tl = listOfCondData.tl;
          var match$6 = listOfCondData.hd;
          var arg2 = match$6.resultExpr;
          var arg1 = match$6.conditionExpr;
          if (tl) {
            if (Caml_obj.caml_equal($$eval(tle, env, arg1), {
                    TAG: /* BoolV */1,
                    _0: true
                  })) {
              _expr = arg2;
              continue ;
            }
            if (!Caml_obj.caml_equal($$eval(tle, env, arg1), {
                    TAG: /* BoolV */1,
                    _0: false
                  })) {
              return Pervasives.failwith("Error: cond expression did not evaluate properly");
            }
            _expr = {
              TAG: /* CondE */6,
              _0: tl
            };
            continue ;
          }
          if (!Caml_obj.caml_equal($$eval(tle, env, arg1), {
                  TAG: /* BoolV */1,
                  _0: true
                })) {
            if (Caml_obj.caml_equal($$eval(tle, env, arg1), {
                    TAG: /* BoolV */1,
                    _0: false
                  })) {
              return Pervasives.failwith("Error: All cond expressions resulted in false");
            } else {
              return Pervasives.failwith("Error: predicate did not evaluate to a bool");
            }
          }
          _expr = arg2;
          continue ;
      case /* LambdaE */7 :
          var match$7 = expr._0;
          return {
                  TAG: /* ClosureV */4,
                  _0: {
                    cNameList: match$7.nameList,
                    cExpr: match$7.lambdaBody,
                    cEnv: env
                  }
                };
      case /* LetE */8 :
          var match$8 = expr._0;
          var exp = match$8.letBody;
          var alop = match$8.letPairs;
          if (alop) {
            if (alop.tl) {
              _expr = exp;
              _env = List.append(addBindingsForLet(/* [] */0, alop), env);
              continue ;
            }
            _expr = exp;
            _env = List.append(addBindingsForLet(/* [] */0, alop), env);
            continue ;
          }
          _expr = exp;
          continue ;
      case /* ApplicationE */9 :
          var match$9 = expr._0;
          if (!match$9) {
            return Pervasives.failwith("Error: This expression is not defined in Rackette");
          }
          var arg = match$9.hd;
          if (typeof arg === "number") {
            return Pervasives.failwith("Error: This expression is not defined in Rackette");
          }
          switch (arg.TAG | 0) {
            case /* NameE */2 :
                var tl$1 = match$9.tl;
                var match$10 = $$eval(tle, env, {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: arg._0._0
                      }
                    });
                switch (match$10.TAG | 0) {
                  case /* BuiltinV */3 :
                      return Curry._1(match$10._0.bProc, evalArgs(tle, env, tl$1));
                  case /* ClosureV */4 :
                      var match$11 = match$10._0;
                      _expr = match$11.cExpr;
                      _env = List.append(addBindingsToClosure(match$11.cNameList, evalArgs(tle, env, tl$1)), match$11.cEnv);
                      continue ;
                  default:
                    return Pervasives.failwith("Error: Procedure was neither a built-in nor a closure");
                }
            case /* LambdaE */7 :
                var match$12 = $$eval(tle, env, {
                      TAG: /* LambdaE */7,
                      _0: arg._0
                    });
                if (match$12.TAG !== /* ClosureV */4) {
                  return Pervasives.failwith("Error: Procedure was not a builtin nor a closure");
                }
                var match$13 = match$12._0;
                _expr = match$13.cExpr;
                _env = List.append(addBindingsToClosure(match$13.cNameList, evalArgs(tle, env, match$9.tl)), match$13.cEnv);
                continue ;
            default:
              return Pervasives.failwith("Error: This expression is not defined in Rackette");
          }
      
    }
  };
}

function addDefinition(env, param) {
  var name = param[0];
  var match = lookup(env, name);
  if (match !== undefined) {
    return Pervasives.failwith("Error: This name was defined previously and cannot be re-defined");
  } else {
    return {
            hd: [
              name,
              $$eval(initialTle, /* [] */0, param[1])
            ],
            tl: env
          };
  }
}

function $$process(pieces) {
  var processHelper = function (_tle, _pieces) {
    while(true) {
      var pieces = _pieces;
      var tle = _tle;
      if (!pieces) {
        return /* [] */0;
      }
      var d = pieces.hd;
      if (d.TAG !== /* Definition */0) {
        return {
                hd: $$eval(tle, /* [] */0, d._0),
                tl: processHelper(tle, pieces.tl)
              };
      }
      _pieces = pieces.tl;
      _tle = addDefinition(tle, d._0);
      continue ;
    };
  };
  return processHelper(initialTle, pieces);
}

function rackette(program) {
  return List.map(stringOfValue, $$process(List.map(parsePiece, Read$Rackette.Reader.readAll(program))));
}

CS17SetupRackette$Rackette.checkExpect(listToString({
          hd: "hi",
          tl: {
            hd: "my",
            tl: {
              hd: "name",
              tl: /* [] */0
            }
          }
        }), "hi my name", "3 elems in list");

CS17SetupRackette$Rackette.checkExpect(listToString({
          hd: "Brown",
          tl: /* [] */0
        }), "Brown", "1 elem in list");

CS17SetupRackette$Rackette.checkExpect(listToString({
          hd: "a",
          tl: {
            hd: "b",
            tl: {
              hd: "c",
              tl: {
                hd: "d",
                tl: /* [] */0
              }
            }
          }
        }), "a b c d", "4 elems in list");

CS17SetupRackette$Rackette.checkExpect(List.append({
          hd: [
            /* Name */{
              _0: "x"
            },
            {
              TAG: /* NumV */0,
              _0: 5
            }
          ],
          tl: /* [] */0
        }, {
          hd: [
            /* Name */{
              _0: "y"
            },
            {
              TAG: /* NumV */0,
              _0: 7
            }
          ],
          tl: /* [] */0
        }), {
      hd: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumV */0,
          _0: 5
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "y"
          },
          {
            TAG: /* NumV */0,
            _0: 7
          }
        ],
        tl: /* [] */0
      }
    }, "testing extendEnv");

CS17SetupRackette$Rackette.checkExpect(List.append({
          hd: [
            /* Name */{
              _0: "x"
            },
            {
              TAG: /* NumV */0,
              _0: 5
            }
          ],
          tl: /* [] */0
        }, /* [] */0), {
      hd: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumV */0,
          _0: 5
        }
      ],
      tl: /* [] */0
    }, "testing extendEnv");

CS17SetupRackette$Rackette.checkExpect(List.append(/* [] */0, /* [] */0), /* [] */0, "testing extendEnv");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ListV */2,
          _0: {
            hd: {
              TAG: /* NumV */0,
              _0: 45
            },
            tl: {
              hd: {
                TAG: /* NumV */0,
                _0: 5
              },
              tl: /* [] */0
            }
          }
        }), "(list 45 5)", "list of numbers");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ListV */2,
          _0: {
            hd: {
              TAG: /* BoolV */1,
              _0: true
            },
            tl: {
              hd: {
                TAG: /* BoolV */1,
                _0: false
              },
              tl: {
                hd: {
                  TAG: /* BoolV */1,
                  _0: true
                },
                tl: /* [] */0
              }
            }
          }
        }), "(list true false true)", "list of booleans");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ListV */2,
          _0: {
            hd: {
              TAG: /* ListV */2,
              _0: {
                hd: {
                  TAG: /* BoolV */1,
                  _0: true
                },
                tl: {
                  hd: {
                    TAG: /* BoolV */1,
                    _0: false
                  },
                  tl: /* [] */0
                }
              }
            },
            tl: {
              hd: {
                TAG: /* ListV */2,
                _0: {
                  hd: {
                    TAG: /* BoolV */1,
                    _0: true
                  },
                  tl: /* [] */0
                }
              },
              tl: /* [] */0
            }
          }
        }), "(list (list true false) (list true))", "list of lists");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* NumV */0,
          _0: 5
        }), "5", "number value");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* BoolV */1,
          _0: true
        }), "true", "boolean value");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* BuiltinV */3,
          _0: {
            bName: "+",
            bProc: plus
          }
        }), "builtin: +", "BuiltinV");

CS17SetupRackette$Rackette.checkExpect(stringOfValue({
          TAG: /* ClosureV */4,
          _0: {
            cNameList: {
              hd: /* Name */{
                _0: "x"
              },
              tl: /* [] */0
            },
            cExpr: {
              TAG: /* NumE */0,
              _0: 5
            },
            cEnv: /* [] */0
          }
        }), "<User-defined procedure>", "ClosureV");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(plus({
              hd: {
                TAG: /* NumV */0,
                _0: 2
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "5", "addition of 2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(plus({
              hd: {
                TAG: /* NumV */0,
                _0: 9
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -1
                },
                tl: /* [] */0
              }
            })), "8", "addition of ints (one is neg.)");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(plus({
              hd: {
                TAG: /* NumV */0,
                _0: 5
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 0
                },
                tl: /* [] */0
              }
            })), "5", "addition of 2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(plus({
              hd: {
                TAG: /* NumV */0,
                _0: -2
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -124
                },
                tl: /* [] */0
              }
            })), "-126", "addition of 2 ints (both are neg.)");

CS17SetupRackette$Rackette.checkError((function (param) {
        return plus({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 3
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 2
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 1
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: + expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return plus({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 6
                    },
                    tl: /* [] */0
                  });
      }), "Error: + expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return plus({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 3
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 2
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 1
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 6
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 56
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: + expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: + expects 2 arguments, but found none");
      }), "Error: + expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(minus({
              hd: {
                TAG: /* NumV */0,
                _0: 4
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "1", "subtraction of 2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(minus({
              hd: {
                TAG: /* NumV */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -12
                },
                tl: /* [] */0
              }
            })), "13", "subtraction of 2 ints (one is neg.)");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(minus({
              hd: {
                TAG: /* NumV */0,
                _0: 5
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 0
                },
                tl: /* [] */0
              }
            })), "5", "subtraction of 2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(minus({
              hd: {
                TAG: /* NumV */0,
                _0: -2
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -124
                },
                tl: /* [] */0
              }
            })), "122", "subtraction of 2 ints (both are neg.)");

CS17SetupRackette$Rackette.checkError((function (param) {
        return minus({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: - expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return minus({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  });
      }), "Error: - expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return minus({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: - expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: - expects 2 arguments, but found none");
      }), "Error: - expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(mult({
              hd: {
                TAG: /* NumV */0,
                _0: 4
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "12", "multiplication of 2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(mult({
              hd: {
                TAG: /* NumV */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -12
                },
                tl: /* [] */0
              }
            })), "-12", "multiplication of 2 ints (one is neg.)");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(mult({
              hd: {
                TAG: /* NumV */0,
                _0: 5
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 0
                },
                tl: /* [] */0
              }
            })), "0", "multiplication of 2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(mult({
              hd: {
                TAG: /* NumV */0,
                _0: -2
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -124
                },
                tl: /* [] */0
              }
            })), "248", "multiplication of 2 ints (both are neg.)");

CS17SetupRackette$Rackette.checkError((function (param) {
        return mult({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: * expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return mult({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  });
      }), "Error: * expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return mult({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: * expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: * expects 2 arguments, but found none");
      }), "Error: * expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(divide({
              hd: {
                TAG: /* NumV */0,
                _0: 4
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "1", "division of 2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(divide({
              hd: {
                TAG: /* NumV */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -12
                },
                tl: /* [] */0
              }
            })), "0", "division of 2 ints (one is neg.)");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(divide({
              hd: {
                TAG: /* NumV */0,
                _0: 5
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            })), "5", "division of 2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(divide({
              hd: {
                TAG: /* NumV */0,
                _0: -54
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -5
                },
                tl: /* [] */0
              }
            })), "10", "division of 2 ints (both are neg.)");

CS17SetupRackette$Rackette.checkError((function (param) {
        return divide({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: / expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return divide({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  });
      }), "Error: / expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return divide({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: / expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: / expects 2 arguments, but found none");
      }), "Error: / expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkError((function (param) {
        return divide({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 4
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 0
                      },
                      tl: /* [] */0
                    }
                  });
      }), "Error: division by 0");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(remainder({
              hd: {
                TAG: /* NumV */0,
                _0: 8
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "2", "remainder of division of 2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(remainder({
              hd: {
                TAG: /* NumV */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -2
                },
                tl: /* [] */0
              }
            })), "1", "remainder of division of 2 ints (one is neg.)");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(remainder({
              hd: {
                TAG: /* NumV */0,
                _0: 5
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            })), "0", "remainder of division of 2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(remainder({
              hd: {
                TAG: /* NumV */0,
                _0: -54
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -5
                },
                tl: /* [] */0
              }
            })), "-4", "remainder of divion of 2 ints (both are neg.)");

CS17SetupRackette$Rackette.checkError((function (param) {
        return remainder({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: remainder expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return remainder({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  });
      }), "Error: remainder expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return remainder({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: remainder expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: remainder expects 2 arguments, but found none");
      }), "Error: remainder expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(equal({
              hd: {
                TAG: /* NumV */0,
                _0: 8
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "false", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(equal({
              hd: {
                TAG: /* NumV */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            })), "true", "2 ints");

CS17SetupRackette$Rackette.checkError((function (param) {
        return equal({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: = expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return equal({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  });
      }), "Error: = expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return equal({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: = expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: = expects 2 arguments, but found none");
      }), "Error: = expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(lessThan({
              hd: {
                TAG: /* NumV */0,
                _0: 4
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "false", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(lessThan({
              hd: {
                TAG: /* NumV */0,
                _0: -800
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 800
                },
                tl: /* [] */0
              }
            })), "true", "2 ints (one is neg.)");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(lessThan({
              hd: {
                TAG: /* NumV */0,
                _0: 0
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 0
                },
                tl: /* [] */0
              }
            })), "false", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(lessThan({
              hd: {
                TAG: /* NumV */0,
                _0: -3
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -124
                },
                tl: /* [] */0
              }
            })), "false", "2 ints (both are neg.)");

CS17SetupRackette$Rackette.checkError((function (param) {
        return lessThan({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: < expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return lessThan({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  });
      }), "Error: < expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return lessThan({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: < expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: < expects 2 arguments, but found none");
      }), "Error: < expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(greaterThan({
              hd: {
                TAG: /* NumV */0,
                _0: 4
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "true", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(greaterThan({
              hd: {
                TAG: /* NumV */0,
                _0: -800
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 800
                },
                tl: /* [] */0
              }
            })), "false", "2 ints (one is neg.)");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(greaterThan({
              hd: {
                TAG: /* NumV */0,
                _0: 0
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 0
                },
                tl: /* [] */0
              }
            })), "false", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(greaterThan({
              hd: {
                TAG: /* NumV */0,
                _0: -3
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -124
                },
                tl: /* [] */0
              }
            })), "true", "2 ints (both are neg.)");

CS17SetupRackette$Rackette.checkError((function (param) {
        return greaterThan({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: > expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return greaterThan({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  });
      }), "Error: > expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return greaterThan({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: > expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: > expects 2 arguments, but found none");
      }), "Error: > expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(lessThanOrEqualTo({
              hd: {
                TAG: /* NumV */0,
                _0: 4
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "false", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(lessThanOrEqualTo({
              hd: {
                TAG: /* NumV */0,
                _0: 23
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "false", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(lessThanOrEqualTo({
              hd: {
                TAG: /* NumV */0,
                _0: -800
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 800
                },
                tl: /* [] */0
              }
            })), "true", "2 ints (one is neg.)");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(lessThanOrEqualTo({
              hd: {
                TAG: /* NumV */0,
                _0: 0
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 0
                },
                tl: /* [] */0
              }
            })), "true", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(lessThanOrEqualTo({
              hd: {
                TAG: /* NumV */0,
                _0: -3
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -124
                },
                tl: /* [] */0
              }
            })), "false", "2 ints (both are neg.)");

CS17SetupRackette$Rackette.checkError((function (param) {
        return lessThanOrEqualTo({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: <= expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return lessThanOrEqualTo({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  });
      }), "Error: <= expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return lessThanOrEqualTo({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: <= expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: <= expects 2 arguments, but found none");
      }), "Error: <= expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(greaterThanOrEqualTo({
              hd: {
                TAG: /* NumV */0,
                _0: 4
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "true", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(greaterThanOrEqualTo({
              hd: {
                TAG: /* NumV */0,
                _0: -800
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 800
                },
                tl: /* [] */0
              }
            })), "false", "2 ints (one is neg.)");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(greaterThanOrEqualTo({
              hd: {
                TAG: /* NumV */0,
                _0: 0
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 0
                },
                tl: /* [] */0
              }
            })), "true", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(greaterThanOrEqualTo({
              hd: {
                TAG: /* NumV */0,
                _0: -3
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -124
                },
                tl: /* [] */0
              }
            })), "true", "2 ints (both are neg.)");

CS17SetupRackette$Rackette.checkError((function (param) {
        return greaterThanOrEqualTo({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: >= expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return greaterThanOrEqualTo({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  });
      }), "Error: >= expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return greaterThanOrEqualTo({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: >= expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: >= expects 2 arguments, but found none");
      }), "Error: >= expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isEqual({
              hd: {
                TAG: /* NumV */0,
                _0: 8
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 3
                },
                tl: /* [] */0
              }
            })), "false", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isEqual({
              hd: {
                TAG: /* NumV */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            })), "true", "2 ints");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isEqual({
              hd: {
                TAG: /* BoolV */1,
                _0: true
              },
              tl: {
                hd: {
                  TAG: /* BoolV */1,
                  _0: true
                },
                tl: /* [] */0
              }
            })), "true", "2 bools");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isEqual({
              hd: {
                TAG: /* BoolV */1,
                _0: false
              },
              tl: {
                hd: {
                  TAG: /* BoolV */1,
                  _0: true
                },
                tl: /* [] */0
              }
            })), "false", "2 bools");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isEqual({
              hd: {
                TAG: /* ListV */2,
                _0: {
                  hd: {
                    TAG: /* NumV */0,
                    _0: 4
                  },
                  tl: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: -3
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListV */2,
                  _0: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: 4
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: -3
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: /* [] */0
              }
            })), "true", "2 lists");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isEqual({
              hd: {
                TAG: /* ListV */2,
                _0: {
                  hd: {
                    TAG: /* NumV */0,
                    _0: 4
                  },
                  tl: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: -3
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ListV */2,
                  _0: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: 4
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: -1
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: /* [] */0
              }
            })), "false", "2 lists");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isEqual({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: equal? expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isEqual({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: /* [] */0
                  });
      }), "Error: equal? expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isEqual({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: true
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: equal? expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: equal? expects 2 arguments, but found none");
      }), "Error: equal? expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isNumber({
              hd: {
                TAG: /* NumV */0,
                _0: 8
              },
              tl: /* [] */0
            })), "true", "Number");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isNumber({
              hd: {
                TAG: /* BoolV */1,
                _0: false
              },
              tl: /* [] */0
            })), "false", "bool");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isNumber({
              hd: {
                TAG: /* ListV */2,
                _0: {
                  hd: {
                    TAG: /* NumV */0,
                    _0: 4
                  },
                  tl: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: -3
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: /* [] */0
            })), "false", "list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isNumber({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: number? expects only 1 argument, but found more than 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isNumber({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: number? expects only 1 argument, but found more than 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: number? expects 1 argument, but found none");
      }), "Error: number? expects 1 argument, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isZero({
              hd: {
                TAG: /* NumV */0,
                _0: 8
              },
              tl: /* [] */0
            })), "false", "Number");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isZero({
              hd: {
                TAG: /* NumV */0,
                _0: 0
              },
              tl: /* [] */0
            })), "true", "Number is 0");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isZero({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: zero? expects only 1 argument, but found more than 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isZero({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: zero? expects only 1 argument, but found more than 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: zero? expects 1 argument, but found none");
      }), "Error: zero? expects 1 argument, but found none");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(cons({
              hd: {
                TAG: /* NumV */0,
                _0: 8
              },
              tl: {
                hd: {
                  TAG: /* ListV */2,
                  _0: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 4
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: /* [] */0
              }
            })), "(list 8 5 4)", "list of numbers");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(cons({
              hd: {
                TAG: /* BoolV */1,
                _0: false
              },
              tl: {
                hd: {
                  TAG: /* ListV */2,
                  _0: /* [] */0
                },
                tl: /* [] */0
              }
            })), "(list false)", "list containing 1 elem");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(cons({
              hd: {
                TAG: /* NumV */0,
                _0: -1
              },
              tl: {
                hd: {
                  TAG: /* ListV */2,
                  _0: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 3
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 6
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            })), "(list -1 5 3 6)", "list of numbers");

CS17SetupRackette$Rackette.checkError((function (param) {
        return cons({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: cons expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return cons({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: /* [] */0
                  });
      }), "Error: cons expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: cons expects 2 arguments, but found none");
      }), "Error: cons expects 2 arguments, but found none");

CS17SetupRackette$Rackette.checkExpect(first({
          hd: {
            TAG: /* ListV */2,
            _0: {
              hd: {
                TAG: /* NumV */0,
                _0: 6
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -3
                },
                tl: /* [] */0
              }
            }
          },
          tl: /* [] */0
        }), {
      TAG: /* NumV */0,
      _0: 6
    }, "list of nums");

CS17SetupRackette$Rackette.checkExpect(first({
          hd: {
            TAG: /* ListV */2,
            _0: {
              hd: {
                TAG: /* NumV */0,
                _0: 4
              },
              tl: /* [] */0
            }
          },
          tl: /* [] */0
        }), {
      TAG: /* NumV */0,
      _0: 4
    }, "list of nums");

CS17SetupRackette$Rackette.checkExpect(first({
          hd: {
            TAG: /* ListV */2,
            _0: {
              hd: {
                TAG: /* BoolV */1,
                _0: true
              },
              tl: {
                hd: {
                  TAG: /* BoolV */1,
                  _0: false
                },
                tl: {
                  hd: {
                    TAG: /* BoolV */1,
                    _0: true
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "list of bools");

CS17SetupRackette$Rackette.checkError((function (param) {
        return first({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: first expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return first({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: /* [] */0
                  });
      }), "Error: first expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return first({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: /* [] */0
                  });
      }), "Error: first expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return first({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: first expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: first expects a non-empty list");
      }), "Error: first expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return first({
                    hd: {
                      TAG: /* ListV */2,
                      _0: /* [] */0
                    },
                    tl: /* [] */0
                  });
      }), "Error: first expects a non-empty list");

CS17SetupRackette$Rackette.checkExpect(rest({
          hd: {
            TAG: /* ListV */2,
            _0: {
              hd: {
                TAG: /* NumV */0,
                _0: 6
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -3
                },
                tl: /* [] */0
              }
            }
          },
          tl: /* [] */0
        }), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* NumV */0,
          _0: -3
        },
        tl: /* [] */0
      }
    }, "list of 2 nums");

CS17SetupRackette$Rackette.checkExpect(rest({
          hd: {
            TAG: /* ListV */2,
            _0: {
              hd: {
                TAG: /* NumV */0,
                _0: 6
              },
              tl: {
                hd: {
                  TAG: /* NumV */0,
                  _0: -3
                },
                tl: {
                  hd: {
                    TAG: /* NumV */0,
                    _0: 5
                  },
                  tl: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: 4
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* NumV */0,
          _0: -3
        },
        tl: {
          hd: {
            TAG: /* NumV */0,
            _0: 5
          },
          tl: {
            hd: {
              TAG: /* NumV */0,
              _0: 4
            },
            tl: /* [] */0
          }
        }
      }
    }, "list of 4 nums");

CS17SetupRackette$Rackette.checkExpect(rest({
          hd: {
            TAG: /* ListV */2,
            _0: {
              hd: {
                TAG: /* NumV */0,
                _0: 4
              },
              tl: /* [] */0
            }
          },
          tl: /* [] */0
        }), {
      TAG: /* ListV */2,
      _0: /* [] */0
    }, "list of nums");

CS17SetupRackette$Rackette.checkExpect(rest({
          hd: {
            TAG: /* ListV */2,
            _0: {
              hd: {
                TAG: /* BoolV */1,
                _0: true
              },
              tl: {
                hd: {
                  TAG: /* BoolV */1,
                  _0: false
                },
                tl: {
                  hd: {
                    TAG: /* BoolV */1,
                    _0: true
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* BoolV */1,
          _0: false
        },
        tl: {
          hd: {
            TAG: /* BoolV */1,
            _0: true
          },
          tl: /* [] */0
        }
      }
    }, "list of bools");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rest({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: rest expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rest({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: /* [] */0
                  });
      }), "Error: rest expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rest({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: /* [] */0
                  });
      }), "Error: rest expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rest({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: rest expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: rest expects a non-empty list");
      }), "Error: rest expects a non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rest({
                    hd: {
                      TAG: /* ListV */2,
                      _0: /* [] */0
                    },
                    tl: /* [] */0
                  });
      }), "Error: rest expects a non-empty list");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isEmpty({
              hd: {
                TAG: /* ListV */2,
                _0: /* [] */0
              },
              tl: /* [] */0
            })), "true", "empty list");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isEmpty({
              hd: {
                TAG: /* ListV */2,
                _0: {
                  hd: {
                    TAG: /* NumV */0,
                    _0: 6
                  },
                  tl: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: -3
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: /* [] */0
            })), "false", "non-empty list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isEmpty({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: empty? expects a list of values as input");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isEmpty({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: /* [] */0
                  });
      }), "Error: empty? expects a list of values as input");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isEmpty({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 2
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 543
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  });
      }), "Error: empty? expects a list of values as input");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: empty? expects a list of values as input");
      }), "Error: empty? expects a list of values as input");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isCons({
              hd: {
                TAG: /* ListV */2,
                _0: /* [] */0
              },
              tl: /* [] */0
            })), "false", "empty list");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(isCons({
              hd: {
                TAG: /* ListV */2,
                _0: {
                  hd: {
                    TAG: /* NumV */0,
                    _0: 6
                  },
                  tl: {
                    hd: {
                      TAG: /* NumV */0,
                      _0: -3
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: /* [] */0
            })), "true", "cons list");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isCons({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: cons? expects only 1 argument, but found more than 1 argument");

CS17SetupRackette$Rackette.checkError((function (param) {
        return isCons({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: {
                            hd: {
                              TAG: /* NumV */0,
                              _0: 543
                            },
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  });
      }), "Error: cons? expects only 1 argument, but found more than 1 argument");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(opposite({
              hd: {
                TAG: /* BoolV */1,
                _0: true
              },
              tl: /* [] */0
            })), "false", "bool is true");

CS17SetupRackette$Rackette.checkExpect(stringOfValue(opposite({
              hd: {
                TAG: /* BoolV */1,
                _0: false
              },
              tl: /* [] */0
            })), "true", "bool is false");

CS17SetupRackette$Rackette.checkError((function (param) {
        return opposite({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 22
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 14
                        },
                        tl: /* [] */0
                      }
                    }
                  });
      }), "Error: not expects either true or false");

CS17SetupRackette$Rackette.checkError((function (param) {
        return opposite({
                    hd: {
                      TAG: /* NumV */0,
                      _0: 34
                    },
                    tl: /* [] */0
                  });
      }), "Error: not expects either true or false");

CS17SetupRackette$Rackette.checkError((function (param) {
        return opposite({
                    hd: {
                      TAG: /* BoolV */1,
                      _0: false
                    },
                    tl: {
                      hd: {
                        TAG: /* NumV */0,
                        _0: 1
                      },
                      tl: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 234
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: 2
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  });
      }), "Error: not expects either true or false");

CS17SetupRackette$Rackette.checkError((function (param) {
        return Pervasives.failwith("Error: not expects 1 argument, but found none");
      }), "Error: not expects 1 argument, but found none");

CS17SetupRackette$Rackette.checkError((function (param) {
        return opposite({
                    hd: {
                      TAG: /* ListV */2,
                      _0: {
                        hd: {
                          TAG: /* NumV */0,
                          _0: 6
                        },
                        tl: {
                          hd: {
                            TAG: /* NumV */0,
                            _0: -3
                          },
                          tl: /* [] */0
                        }
                      }
                    },
                    tl: /* [] */0
                  });
      }), "Error: not expects either true or false");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "x"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 5
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "x"
      },
      {
        TAG: /* NumE */0,
        _0: 5
      }
    ], "parsing a definition containing a number expression");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "plus"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "+"
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "plus"
      },
      {
        TAG: /* NameE */2,
        _0: /* Name */{
          _0: "+"
        }
      }
    ], "parsing a definition containing a symbol");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "fun"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "lambda"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "x"
                          },
                          tl: /* [] */0
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* ListC */2,
                          _0: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "+"
                            },
                            tl: {
                              hd: {
                                TAG: /* SymbolC */1,
                                _0: "x"
                              },
                              tl: {
                                hd: {
                                  TAG: /* NumberC */0,
                                  _0: 1
                                },
                                tl: /* [] */0
                              }
                            }
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "fun"
      },
      {
        TAG: /* LambdaE */7,
        _0: {
          nameList: {
            hd: /* Name */{
              _0: "x"
            },
            tl: /* [] */0
          },
          lambdaBody: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "+"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 1
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    ], "parsing a definition containing a lambda expression");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "fun"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "let"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* ListC */2,
                            _0: {
                              hd: {
                                TAG: /* SymbolC */1,
                                _0: "x"
                              },
                              tl: {
                                hd: {
                                  TAG: /* NumberC */0,
                                  _0: 0
                                },
                                tl: /* [] */0
                              }
                            }
                          },
                          tl: /* [] */0
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* ListC */2,
                          _0: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "+"
                            },
                            tl: {
                              hd: {
                                TAG: /* SymbolC */1,
                                _0: "x"
                              },
                              tl: {
                                hd: {
                                  TAG: /* NumberC */0,
                                  _0: 1
                                },
                                tl: /* [] */0
                              }
                            }
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "fun"
      },
      {
        TAG: /* LetE */8,
        _0: {
          letPairs: {
            hd: {
              pairName: /* Name */{
                _0: "x"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 0
              }
            },
            tl: /* [] */0
          },
          letBody: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "+"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 1
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    ], "parsing a definition containing a let expression");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "hello"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "or"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "<="
                          },
                          tl: {
                            hd: {
                              TAG: /* NumberC */0,
                              _0: 6
                            },
                            tl: {
                              hd: {
                                TAG: /* NumberC */0,
                                _0: 7
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* ListC */2,
                          _0: {
                            hd: {
                              TAG: /* SymbolC */1,
                              _0: "number?"
                            },
                            tl: {
                              hd: {
                                TAG: /* NumberC */0,
                                _0: 5
                              },
                              tl: /* [] */0
                            }
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "hello"
      },
      {
        TAG: /* OrE */4,
        _0: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "<="
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 6
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 7
                },
                tl: /* [] */0
              }
            }
          }
        },
        _1: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "number?"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 5
              },
              tl: /* [] */0
            }
          }
        }
      }
    ], "parsing a definition containing an or expression");

CS17SetupRackette$Rackette.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "h"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "x"
                    },
                    tl: {
                      hd: {
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* SymbolC */1,
                            _0: "+"
                          },
                          tl: {
                            hd: {
                              TAG: /* NumberC */0,
                              _0: 4
                            },
                            tl: {
                              hd: {
                                TAG: /* NumberC */0,
                                _0: 5
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "h"
      },
      {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "x"
            }
          },
          tl: {
            hd: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 4
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 5
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            tl: /* [] */0
          }
        }
      }
    ], "parsing a definition to an application expression");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* NumberC */0,
          _0: 5
        }), {
      TAG: /* NumE */0,
      _0: 5
    }, "parsing a number");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* NumberC */0,
          _0: 0
        }), {
      TAG: /* NumE */0,
      _0: 0
    }, "parsing 0");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "+"
        }), {
      TAG: /* NameE */2,
      _0: /* Name */{
        _0: "+"
      }
    }, "parsing a symbol");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "cons?"
        }), {
      TAG: /* NameE */2,
      _0: /* Name */{
        _0: "cons?"
      }
    }, "parsing a builtin");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "or"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "false"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "false"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* OrE */4,
      _0: {
        TAG: /* BoolE */1,
        _0: false
      },
      _1: {
        TAG: /* BoolE */1,
        _0: false
      }
    }, "parsing an or expr");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "and"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: ">"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 4
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 1
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "true"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* AndE */3,
      _0: {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: ">"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 4
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 1
              },
              tl: /* [] */0
            }
          }
        }
      },
      _1: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "parsing an and expr w/ an proc app expr inside");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "or"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "false"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "<="
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 6
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 1
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* OrE */4,
      _0: {
        TAG: /* BoolE */1,
        _0: false
      },
      _1: {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "<="
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 6
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 1
              },
              tl: /* [] */0
            }
          }
        }
      }
    }, "parsing an or expr w/ an proc app expr inside");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(and (= 4 1) (> 6 2))")), {
      TAG: /* AndE */3,
      _0: {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "="
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 4
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 1
              },
              tl: /* [] */0
            }
          }
        }
      },
      _1: {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: ">"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 6
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 2
              },
              tl: /* [] */0
            }
          }
        }
      }
    }, "parsing and exp w/ 2 proc app expr");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(if (zero? x) 1 (+ x 5))")), {
      TAG: /* IfE */5,
      _0: {
        boolExpr: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "zero?"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: /* [] */0
            }
          }
        },
        trueExpr: {
          TAG: /* NumE */0,
          _0: 1
        },
        falseExpr: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 5
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parsing if expr");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(if (> y x) (+ x y) (+ x (- y 6)))")), {
      TAG: /* IfE */5,
      _0: {
        boolExpr: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: ">"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "y"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        },
        trueExpr: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        },
        falseExpr: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "-"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "y"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 6
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parsing if expr with nested expr");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(lambda (x) (+ x 1))")), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: /* [] */0
        },
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parsing lambda expr");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(lambda (x y) (+ x 1))")), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: {
            hd: /* Name */{
              _0: "y"
            },
            tl: /* [] */0
          }
        },
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parsing another lambda expr");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(lambda (x y) (+ x y))")), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: {
            hd: /* Name */{
              _0: "y"
            },
            tl: /* [] */0
          }
        },
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parsing a lambda expr where both args are in the body");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(lambda (x y z) (+ x (* z y)))")), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: {
            hd: /* Name */{
              _0: "y"
            },
            tl: {
              hd: /* Name */{
                _0: "z"
              },
              tl: /* [] */0
            }
          }
        },
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "*"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "z"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "y"
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parsing a lambda expr w/ nested proc app expr in the body");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(let ((x 5)) (+ x 1))")), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 5
            }
          },
          tl: /* [] */0
        },
        letBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parsing a let expr");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(let ((x 5) (y 3)) (+ y 1))")), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 5
            }
          },
          tl: {
            hd: {
              pairName: /* Name */{
                _0: "y"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 3
              }
            },
            tl: /* [] */0
          }
        },
        letBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "y"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parsing a let expr with 2 bindings");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(let ((x 5) (y 3) (z 1)) (+ (* x z) (- y 4)))")), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 5
            }
          },
          tl: {
            hd: {
              pairName: /* Name */{
                _0: "y"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 3
              }
            },
            tl: {
              hd: {
                pairName: /* Name */{
                  _0: "z"
                },
                pairExpr: {
                  TAG: /* NumE */0,
                  _0: 1
                }
              },
              tl: /* [] */0
            }
          }
        },
        letBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "*"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "x"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "z"
                        }
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "-"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "y"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 4
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parsing a let expr with more than 2 bindings");

CS17SetupRackette$Rackette.checkExpectExpression(parseExpression(Read$Rackette.Reader.read("(cond ((zero? x) 1) ((not (zero? x)) 2))")), {
      TAG: /* CondE */6,
      _0: {
        hd: {
          conditionExpr: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "zero?"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: /* [] */0
              }
            }
          },
          resultExpr: {
            TAG: /* NumE */0,
            _0: 1
          }
        },
        tl: {
          hd: {
            conditionExpr: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "not"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "zero?"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "x"
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  tl: /* [] */0
                }
              }
            },
            resultExpr: {
              TAG: /* NumE */0,
              _0: 2
            }
          },
          tl: /* [] */0
        }
      }
    }, "parsing a cond expression");

CS17SetupRackette$Rackette.checkExpect(lookup({
          hd: [
            /* Name */{
              _0: "x"
            },
            {
              TAG: /* NumV */0,
              _0: 5
            }
          ],
          tl: /* [] */0
        }, /* Name */{
          _0: "x"
        }), {
      TAG: /* NumV */0,
      _0: 5
    }, "testing lookup for a number value");

CS17SetupRackette$Rackette.checkExpect(lookup({
          hd: [
            /* Name */{
              _0: "a"
            },
            {
              TAG: /* NumV */0,
              _0: 5
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: "b"
              },
              {
                TAG: /* BoolV */1,
                _0: true
              }
            ],
            tl: /* [] */0
          }
        }, /* Name */{
          _0: "b"
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "testing lookup for a boolean value");

CS17SetupRackette$Rackette.checkExpect(lookup({
          hd: [
            /* Name */{
              _0: "y"
            },
            {
              TAG: /* ListV */2,
              _0: {
                hd: {
                  TAG: /* NumV */0,
                  _0: 5
                },
                tl: {
                  hd: {
                    TAG: /* NumV */0,
                    _0: 6
                  },
                  tl: /* [] */0
                }
              }
            }
          ],
          tl: /* [] */0
        }, /* Name */{
          _0: "y"
        }), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* NumV */0,
          _0: 5
        },
        tl: {
          hd: {
            TAG: /* NumV */0,
            _0: 6
          },
          tl: /* [] */0
        }
      }
    }, "testing lookup for a listV value");

CS17SetupRackette$Rackette.checkExpect(uniqueListP({
          hd: /* Name */{
            _0: "x"
          },
          tl: {
            hd: /* Name */{
              _0: "y"
            },
            tl: {
              hd: /* Name */{
                _0: "z"
              },
              tl: /* [] */0
            }
          }
        }), true, "testing a unique list");

CS17SetupRackette$Rackette.checkExpect(uniqueListP({
          hd: /* Name */{
            _0: "x"
          },
          tl: {
            hd: /* Name */{
              _0: "x"
            },
            tl: /* [] */0
          }
        }), false, "testing a non-unique list");

CS17SetupRackette$Rackette.checkExpect(true, true, "testing a unique list");

CS17SetupRackette$Rackette.checkExpect(addBindingsToClosure({
          hd: /* Name */{
            _0: "x"
          },
          tl: {
            hd: /* Name */{
              _0: "y"
            },
            tl: /* [] */0
          }
        }, {
          hd: {
            TAG: /* NumV */0,
            _0: 5
          },
          tl: {
            hd: {
              TAG: /* NumV */0,
              _0: 6
            },
            tl: /* [] */0
          }
        }), {
      hd: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumV */0,
          _0: 5
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "y"
          },
          {
            TAG: /* NumV */0,
            _0: 6
          }
        ],
        tl: /* [] */0
      }
    }, "testing addBindingsToClosure");

CS17SetupRackette$Rackette.checkExpect(addBindingsToClosure({
          hd: /* Name */{
            _0: "brown"
          },
          tl: /* [] */0
        }, {
          hd: {
            TAG: /* BoolV */1,
            _0: true
          },
          tl: /* [] */0
        }), {
      hd: [
        /* Name */{
          _0: "brown"
        },
        {
          TAG: /* BoolV */1,
          _0: true
        }
      ],
      tl: /* [] */0
    }, "testing addBindingsToClosure");

CS17SetupRackette$Rackette.checkExpect({
      hd: [
        /* Name */{
          _0: "y"
        },
        {
          TAG: /* BoolV */1,
          _0: true
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumV */0,
            _0: 5
          }
        ],
        tl: /* [] */0
      }
    }, {
      hd: [
        /* Name */{
          _0: "y"
        },
        {
          TAG: /* BoolV */1,
          _0: true
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumV */0,
            _0: 5
          }
        ],
        tl: /* [] */0
      }
    }, "add bindings to an env");

CS17SetupRackette$Rackette.checkExpect({
      hd: [
        /* Name */{
          _0: "y"
        },
        {
          TAG: /* BoolV */1,
          _0: true
        }
      ],
      tl: /* [] */0
    }, {
      hd: [
        /* Name */{
          _0: "y"
        },
        {
          TAG: /* BoolV */1,
          _0: true
        }
      ],
      tl: /* [] */0
    }, "add bindings to an empty env");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* AndE */3,
              _0: {
                TAG: /* BoolE */1,
                _0: true
              },
              _1: {
                TAG: /* BoolE */1,
                _0: true
              }
            })), "true", "eval another simple and-expr");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* AndE */3,
              _0: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "<"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 5
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 3
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              _1: {
                TAG: /* BoolE */1,
                _0: true
              }
            })), "false", "eval and-expr w/ proc-app expr");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* OrE */4,
              _0: {
                TAG: /* BoolE */1,
                _0: false
              },
              _1: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: ">="
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 6
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 1
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            })), "true", "eval or-expr w/ proc-app expr");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* IfE */5,
              _0: {
                boolExpr: {
                  TAG: /* BoolE */1,
                  _0: false
                },
                trueExpr: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "*"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 143
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: -5
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                falseExpr: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "number?"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 5
                      },
                      tl: /* [] */0
                    }
                  }
                }
              }
            })), "true", "eval if-expr w/ mutliple proc-app expressions");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 3
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 5
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "8", "eval proc-app expr w/ addition");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "number?"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 4
                  },
                  tl: /* [] */0
                }
              }
            })), "true", "eval proc-app expr w/ number?");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "*"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 5
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 4
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "20", "eval proc-app expr w/ mult");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "/"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 123
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 5
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "24", "eval proc-app expr w/ divide");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "zero?"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 0
                  },
                  tl: /* [] */0
                }
              }
            })), "true", "eval proc-app expr w/ zero?");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "="
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 0
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "true", "eval proc-app expr w/ =");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "<="
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 0
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "true", "eval proc-app expr w/ <=");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: ">="
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 234
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 0
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "true", "eval proc-app expr w/ >=");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "equal?"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* BoolE */1,
                    _0: false
                  },
                  tl: {
                    hd: {
                      TAG: /* BoolE */1,
                      _0: true
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "false", "eval proc-app expr w/ equal?");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, {
              hd: [
                /* Name */{
                  _0: "x"
                },
                {
                  TAG: /* NumV */0,
                  _0: 4
                }
              ],
              tl: /* [] */0
            }, {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "x"
              }
            })), "4", "eval a name expression");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* CondE */6,
              _0: {
                hd: {
                  conditionExpr: {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "zero?"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 2
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  resultExpr: {
                    TAG: /* NumE */0,
                    _0: 1
                  }
                },
                tl: {
                  hd: {
                    conditionExpr: {
                      TAG: /* ApplicationE */9,
                      _0: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "zero?"
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* NumE */0,
                            _0: 0
                          },
                          tl: /* [] */0
                        }
                      }
                    },
                    resultExpr: {
                      TAG: /* NumE */0,
                      _0: 2
                    }
                  },
                  tl: /* [] */0
                }
              }
            })), "2", "eval cond expression w/ 2 branches");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, /* [] */0, {
              TAG: /* CondE */6,
              _0: {
                hd: {
                  conditionExpr: {
                    TAG: /* ApplicationE */9,
                    _0: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "zero?"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 2
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  resultExpr: {
                    TAG: /* NumE */0,
                    _0: 1
                  }
                },
                tl: {
                  hd: {
                    conditionExpr: {
                      TAG: /* ApplicationE */9,
                      _0: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "number?"
                          }
                        },
                        tl: {
                          hd: {
                            TAG: /* BoolE */1,
                            _0: false
                          },
                          tl: /* [] */0
                        }
                      }
                    },
                    resultExpr: {
                      TAG: /* NumE */0,
                      _0: 2
                    }
                  },
                  tl: {
                    hd: {
                      conditionExpr: {
                        TAG: /* ApplicationE */9,
                        _0: {
                          hd: {
                            TAG: /* NameE */2,
                            _0: /* Name */{
                              _0: "equal?"
                            }
                          },
                          tl: {
                            hd: {
                              TAG: /* BoolE */1,
                              _0: true
                            },
                            tl: {
                              hd: {
                                TAG: /* BoolE */1,
                                _0: true
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      },
                      resultExpr: {
                        TAG: /* NumE */0,
                        _0: 9
                      }
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "9", "eval cond expression w/ 3 branches");

CS17SetupRackette$Rackette.checkExpect(addDefinition(/* [] */0, [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumE */0,
            _0: 5
          }
        ]), {
      hd: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumV */0,
          _0: 5
        }
      ],
      tl: /* [] */0
    }, "adding a single binding to empty environment");

CS17SetupRackette$Rackette.checkExpect(addDefinition({
          hd: [
            /* Name */{
              _0: "y"
            },
            {
              TAG: /* BoolV */1,
              _0: true
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: "z"
              },
              {
                TAG: /* NumV */0,
                _0: 4
              }
            ],
            tl: /* [] */0
          }
        }, [
          /* Name */{
            _0: "f"
          },
          {
            TAG: /* NumE */0,
            _0: 5
          }
        ]), {
      hd: [
        /* Name */{
          _0: "f"
        },
        {
          TAG: /* NumV */0,
          _0: 5
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "y"
          },
          {
            TAG: /* BoolV */1,
            _0: true
          }
        ],
        tl: {
          hd: [
            /* Name */{
              _0: "z"
            },
            {
              TAG: /* NumV */0,
              _0: 4
            }
          ],
          tl: /* [] */0
        }
      }
    }, "adding a single binding to env that is not empty");

CS17SetupRackette$Rackette.checkError((function (param) {
        return addDefinition({
                    hd: [
                      /* Name */{
                        _0: "y"
                      },
                      {
                        TAG: /* BoolV */1,
                        _0: true
                      }
                    ],
                    tl: /* [] */0
                  }, [
                    /* Name */{
                      _0: "y"
                    },
                    {
                      TAG: /* NumE */0,
                      _0: 1
                    }
                  ]);
      }), "Error: This name was defined previously and cannot be re-defined");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, {
              hd: [
                /* Name */{
                  _0: "x"
                },
                {
                  TAG: /* NumV */0,
                  _0: 5
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "y"
                  },
                  {
                    TAG: /* NumV */0,
                    _0: 6
                  }
                ],
                tl: /* [] */0
              }
            }, {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "x"
              }
            })), "5", "evaluating a name in the local env");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval(initialTle, {
              hd: [
                /* Name */{
                  _0: "x"
                },
                {
                  TAG: /* BoolV */1,
                  _0: true
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "y"
                  },
                  {
                    TAG: /* NumV */0,
                    _0: 6
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: "z"
                    },
                    {
                      TAG: /* BoolV */1,
                      _0: false
                    }
                  ],
                  tl: /* [] */0
                }
              }
            }, {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "z"
              }
            })), "false", "evaluating another name in the local env");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval({
              hd: [
                /* Name */{
                  _0: "a"
                },
                {
                  TAG: /* BoolV */1,
                  _0: true
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "b"
                  },
                  {
                    TAG: /* NumV */0,
                    _0: 7
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: "c"
                    },
                    {
                      TAG: /* BoolV */1,
                      _0: false
                    }
                  ],
                  tl: /* [] */0
                }
              }
            }, {
              hd: [
                /* Name */{
                  _0: "a"
                },
                {
                  TAG: /* NumV */0,
                  _0: 10
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "y"
                  },
                  {
                    TAG: /* NumV */0,
                    _0: 6
                  }
                ],
                tl: /* [] */0
              }
            }, {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "a"
              }
            })), "10", "evaluating a name in the TLE");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval({
              hd: [
                /* Name */{
                  _0: "y"
                },
                {
                  TAG: /* NumV */0,
                  _0: 4
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "+"
                  },
                  {
                    TAG: /* BuiltinV */3,
                    _0: {
                      bName: "<builtin-proc-+",
                      bProc: plus
                    }
                  }
                ],
                tl: /* [] */0
              }
            }, {
              hd: [
                /* Name */{
                  _0: "x"
                },
                {
                  TAG: /* NumV */0,
                  _0: 4
                }
              ],
              tl: /* [] */0
            }, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 1
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "5", "evaluating app proc expression");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval({
              hd: [
                /* Name */{
                  _0: "x"
                },
                {
                  TAG: /* NumV */0,
                  _0: 4
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "*"
                  },
                  {
                    TAG: /* BuiltinV */3,
                    _0: {
                      bName: "<builtin-proc-*",
                      bProc: mult
                    }
                  }
                ],
                tl: /* [] */0
              }
            }, {
              hd: [
                /* Name */{
                  _0: "x"
                },
                {
                  TAG: /* NumV */0,
                  _0: 1
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "y"
                  },
                  {
                    TAG: /* NumV */0,
                    _0: 6
                  }
                ],
                tl: /* [] */0
              }
            }, {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "*"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 1
                    },
                    tl: /* [] */0
                  }
                }
              }
            })), "1", "evaluating app proc expression");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval({
              hd: [
                /* Name */{
                  _0: "a"
                },
                {
                  TAG: /* BoolV */1,
                  _0: true
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "b"
                  },
                  {
                    TAG: /* NumV */0,
                    _0: 7
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: "c"
                    },
                    {
                      TAG: /* BoolV */1,
                      _0: false
                    }
                  ],
                  tl: {
                    hd: [
                      /* Name */{
                        _0: "+"
                      },
                      {
                        TAG: /* BuiltinV */3,
                        _0: {
                          bName: "<builtin-proc-+",
                          bProc: plus
                        }
                      }
                    ],
                    tl: /* [] */0
                  }
                }
              }
            }, /* [] */0, {
              TAG: /* LetE */8,
              _0: {
                letPairs: {
                  hd: {
                    pairName: /* Name */{
                      _0: "x"
                    },
                    pairExpr: {
                      TAG: /* NumE */0,
                      _0: 5
                    }
                  },
                  tl: /* [] */0
                },
                letBody: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "+"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "x"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 1
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            })), "6", "evaluating a let expression");

CS17SetupRackette$Rackette.checkExpect(stringOfValue($$eval({
              hd: [
                /* Name */{
                  _0: "a"
                },
                {
                  TAG: /* BoolV */1,
                  _0: true
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "b"
                  },
                  {
                    TAG: /* NumV */0,
                    _0: 7
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: "c"
                    },
                    {
                      TAG: /* NumV */0,
                      _0: 6
                    }
                  ],
                  tl: {
                    hd: [
                      /* Name */{
                        _0: "+"
                      },
                      {
                        TAG: /* BuiltinV */3,
                        _0: {
                          bName: "<builtin-proc-+",
                          bProc: plus
                        }
                      }
                    ],
                    tl: /* [] */0
                  }
                }
              }
            }, /* [] */0, {
              TAG: /* LetE */8,
              _0: {
                letPairs: {
                  hd: {
                    pairName: /* Name */{
                      _0: "b"
                    },
                    pairExpr: {
                      TAG: /* NumE */0,
                      _0: 5
                    }
                  },
                  tl: {
                    hd: {
                      pairName: /* Name */{
                        _0: "c"
                      },
                      pairExpr: {
                        TAG: /* NumE */0,
                        _0: 9
                      }
                    },
                    tl: /* [] */0
                  }
                },
                letBody: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "+"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "b"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NameE */2,
                          _0: /* Name */{
                            _0: "c"
                          }
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            })), "14", "evaluating a let expression");

CS17SetupRackette$Rackette.checkExpect($$eval({
          hd: [
            /* Name */{
              _0: "a"
            },
            {
              TAG: /* BoolV */1,
              _0: true
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: "b"
              },
              {
                TAG: /* NumV */0,
                _0: 7
              }
            ],
            tl: {
              hd: [
                /* Name */{
                  _0: "c"
                },
                {
                  TAG: /* NumV */0,
                  _0: 6
                }
              ],
              tl: /* [] */0
            }
          }
        }, {
          hd: [
            /* Name */{
              _0: "x"
            },
            {
              TAG: /* NumV */0,
              _0: 6
            }
          ],
          tl: /* [] */0
        }, {
          TAG: /* LambdaE */7,
          _0: {
            nameList: {
              hd: /* Name */{
                _0: "x"
              },
              tl: /* [] */0
            },
            lambdaBody: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 1
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          }
        }), {
      TAG: /* ClosureV */4,
      _0: {
        cNameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: /* [] */0
        },
        cExpr: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            }
          }
        },
        cEnv: {
          hd: [
            /* Name */{
              _0: "x"
            },
            {
              TAG: /* NumV */0,
              _0: 6
            }
          ],
          tl: /* [] */0
        }
      }
    }, "evaluating a lambda expression to a closure");

CS17SetupRackette$Rackette.checkExpect($$eval({
          hd: [
            /* Name */{
              _0: "a"
            },
            {
              TAG: /* BoolV */1,
              _0: true
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: "b"
              },
              {
                TAG: /* NumV */0,
                _0: 7
              }
            ],
            tl: {
              hd: [
                /* Name */{
                  _0: "c"
                },
                {
                  TAG: /* NumV */0,
                  _0: 6
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "*"
                  },
                  {
                    TAG: /* BuiltinV */3,
                    _0: {
                      bName: "<builtin-proc-*",
                      bProc: mult
                    }
                  }
                ],
                tl: /* [] */0
              }
            }
          }
        }, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* LambdaE */7,
              _0: {
                nameList: {
                  hd: /* Name */{
                    _0: "x"
                  },
                  tl: /* [] */0
                },
                lambdaBody: {
                  TAG: /* ApplicationE */9,
                  _0: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "*"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: "x"
                        }
                      },
                      tl: {
                        hd: {
                          TAG: /* NumE */0,
                          _0: 1
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 1
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 1
    }, "evaluating an app proc expr w/ closure");

CS17SetupRackette$Rackette.checkExpect(rackette("(+ 3 1)"), {
      hd: "4",
      tl: /* [] */0
    }, "testing a simple proc app expr");

CS17SetupRackette$Rackette.checkExpect(rackette("(zero? 8)"), {
      hd: "false",
      tl: /* [] */0
    }, "testing zero?");

CS17SetupRackette$Rackette.checkExpect(rackette("(+ 3 (* 5 1))"), {
      hd: "8",
      tl: /* [] */0
    }, "testing a simple nested proc app expr");

CS17SetupRackette$Rackette.checkExpect(rackette("(- (/ 7 3) (* 5 1))"), {
      hd: "-3",
      tl: /* [] */0
    }, "testing a proc app expr w/ 2 nested expressions");

CS17SetupRackette$Rackette.checkExpect(rackette("(number? false)"), {
      hd: "false",
      tl: /* [] */0
    }, "testing a number?");

CS17SetupRackette$Rackette.checkExpect(rackette("(and (< 5 6) (>= 1 4))"), {
      hd: "false",
      tl: /* [] */0
    }, "testing an and expr");

CS17SetupRackette$Rackette.checkExpect(rackette("(or (zero? 5) (= 1 1))"), {
      hd: "true",
      tl: /* [] */0
    }, "testing an or expr");

CS17SetupRackette$Rackette.checkExpect(rackette("(if (> 4 1) (+ 6 2) (- 2 8))"), {
      hd: "8",
      tl: /* [] */0
    }, "testing a basic if expr");

CS17SetupRackette$Rackette.checkExpect(rackette("(if (and (= 7 7) (> 7 1)) (or (number? 6) (equal? true false)) 7)"), {
      hd: "true",
      tl: /* [] */0
    }, "testing an if statement w/ multiple proc apps inside");

CS17SetupRackette$Rackette.checkExpect(rackette("(let ((x 5)) (* x 7))"), {
      hd: "35",
      tl: /* [] */0
    }, "testing a simple let expr");

CS17SetupRackette$Rackette.checkExpect(rackette("(let ((x 5) (y 6)) (* x y))"), {
      hd: "30",
      tl: /* [] */0
    }, "testing a let expr w/ 2 bindings");

CS17SetupRackette$Rackette.checkExpect(rackette("((lambda (x) (+ x 1)) 7)"), {
      hd: "8",
      tl: /* [] */0
    }, "testing a simple lambda expression");

CS17SetupRackette$Rackette.checkExpect(rackette("((lambda (x y) (+ x y)) 1 2)"), {
      hd: "3",
      tl: /* [] */0
    }, "testing a lambda expression w/ 2 arguments");

CS17SetupRackette$Rackette.checkExpect(rackette("((lambda (x y z) (+ x (- y z))) 7 8 9)"), {
      hd: "6",
      tl: /* [] */0
    }, "testing a lambda expression w/ 3 arguments");

CS17SetupRackette$Rackette.checkExpect(rackette("((lambda (x y) ((lambda (y) (+ x y)) x)) 17 18)"), {
      hd: "34",
      tl: /* [] */0
    }, "testing nested lambda expressions");

CS17SetupRackette$Rackette.checkExpect(rackette("((lambda (x y) ((lambda (x) (+ x y)) x)) 17 18)"), {
      hd: "35",
      tl: /* [] */0
    }, "testing nested lambda expressions");

CS17SetupRackette$Rackette.checkExpect(rackette("((lambda (x y) ((lambda (x) (+ x y)) y)) 17 18)"), {
      hd: "36",
      tl: /* [] */0
    }, "testing nested lambda expressions");

CS17SetupRackette$Rackette.checkExpect(rackette("(define y 17) (let ((y 3)) (+ y 7))"), {
      hd: "10",
      tl: /* [] */0
    }, "testing define and let expressions");

CS17SetupRackette$Rackette.checkExpect(rackette("*"), {
      hd: "builtin: <builtin-proc-*",
      tl: /* [] */0
    }, "testing a single symbol");

CS17SetupRackette$Rackette.checkExpect(rackette("cons"), {
      hd: "builtin: <builtin-proc-cons",
      tl: /* [] */0
    }, "testing a single symbol without parentheses");

CS17SetupRackette$Rackette.checkExpect(rackette("(cons 1 empty)"), {
      hd: "(list 1)",
      tl: /* [] */0
    }, "testing cons on an empty list");

CS17SetupRackette$Rackette.checkExpect(rackette("> 5 1 2 5 2"), {
      hd: "builtin: <builtin-proc->",
      tl: {
        hd: "5",
        tl: {
          hd: "1",
          tl: {
            hd: "2",
            tl: {
              hd: "5",
              tl: {
                hd: "2",
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "testing > without parentheses");

CS17SetupRackette$Rackette.checkExpect(rackette("(let ((x 0)) (let ((f (lambda (a) (* x a)))) (let ((x 1)) (f 5))))"), {
      hd: "0",
      tl: /* [] */0
    }, "testing let and lambda expressions");

CS17SetupRackette$Rackette.checkExpect(rackette("(let ((x 0) (y 18)) (let ((f (lambda (a b) (+ x b))) (x 17)) (f y x)))"), {
      hd: "17",
      tl: /* [] */0
    }, "testing let and lambda expressions w/ 2 bindings for let");

CS17SetupRackette$Rackette.checkExpect(rackette("(let () (+ 3 5))"), {
      hd: "8",
      tl: /* [] */0
    }, "testing a let expr with 0 bindings");

CS17SetupRackette$Rackette.checkExpect(rackette("(cond ((zero? 1) 6) ((not (zero? 5)) 5))"), {
      hd: "5",
      tl: /* [] */0
    }, "testing a basic cond expression");

CS17SetupRackette$Rackette.checkExpect(rackette("(define fact 5) fact"), {
      hd: "5",
      tl: /* [] */0
    }, "testing a simple define expression");

CS17SetupRackette$Rackette.checkExpect(rackette("(define fact (lambda (x) (+ x 14))) (fact 3)"), {
      hd: "17",
      tl: /* [] */0
    }, "testing a define expression w/ lambda");

CS17SetupRackette$Rackette.checkExpect(rackette("(define fact (lambda (x) (if (zero? x) 1 (* x (fact (- x 1)))))) (fact 3)"), {
      hd: "6",
      tl: /* [] */0
    }, "testing define and lambda expressions");

CS17SetupRackette$Rackette.checkExpect(rackette("(define max2 (lambda (a b) (if (> a b) a b)))\n(define right-max (lambda (aloi) (cond\n    ((empty? aloi) empty)\n    ((empty? (rest aloi)) aloi)\n    ((cons? aloi) (cons (max2 (first aloi) (first (right-max (rest aloi))))\n                        (right-max (rest aloi))))))) (right-max(cons 4 (cons 6 (cons 5 empty))))"), {
      hd: "(list 6 6 5)",
      tl: /* [] */0
    }, "testing right-max");

CS17SetupRackette$Rackette.checkExpect(rackette("(lambda (x) (+ x 1))"), {
      hd: "<User-defined procedure>",
      tl: /* [] */0
    }, "testing a user-defined procedure");

CS17SetupRackette$Rackette.checkExpect(rackette("(lambda (x y) (+ x (- y x)))"), {
      hd: "<User-defined procedure>",
      tl: /* [] */0
    }, "testing a user-defined procedure w/ two formal arguments");

CS17SetupRackette$Rackette.checkExpect(rackette("(define digit-add (lambda (a b)\n  (if (and (number? a)\n           (and (number? b)\n           (and (<= 0 a)\n           (and (<= a 99)\n           (and (<= 0 b)\n           (and (<= b 99)\n           (<= (+ a b) 99)))))))\n      (+ a b) 0)))\n\n(define digit-sub (lambda (a b)\n  (if (and (number? a)\n           (and (number? b)\n           (and (<= 0 a)\n           (and (<= a 99)\n           (and (<= 0 b)\n           (and (<= b 99)\n           (>= (- a b) 0)))))))\n      (- a b)\n      0)))\n\n(define bignum+ (lambda (bignum1 bignum2)\n (if (or (empty? bignum1) (empty? bignum2))\n  (if (empty? bignum1) bignum2 bignum1)\n  (if (> (digit-add (first bignum1) (first bignum2)) 9)\n      (cons (digit-sub (digit-add (first bignum1) (first bignum2)) 10)\n            (bignum+ (cons 1 empty) (bignum+ (rest bignum1) (rest bignum2))))\n      (cons (digit-add (first bignum1) (first bignum2))\n            (bignum+ (rest bignum1) (rest bignum2)))))))\n            (bignum+ (cons 9 empty) (cons 1 empty))"), {
      hd: "(list 0 1)",
      tl: /* [] */0
    }, "testing bignum+");

CS17SetupRackette$Rackette.checkExpect(rackette("\n(define subset-sum (lambda (weights target)\n  (cond\n    ((empty? weights) (zero? target))\n    ((cons? weights) (or (subset-sum (rest weights) (- target (first weights)))\n                         (subset-sum (rest weights) target))))))(subset-sum (cons 1 (cons 2 empty)) 2)"), {
      hd: "true",
      tl: /* [] */0
    }, "testing subset-sum");

CS17SetupRackette$Rackette.checkExpect(rackette("\n(define lengthen (lambda (alon)\n  (cond\n    ((empty? alon) (cons 0 empty))\n    ((cons? alon) (cons (first alon) (lengthen (rest alon)))))))(lengthen (cons 1 (cons 2 empty)))"), {
      hd: "(list 1 2 0)",
      tl: /* [] */0
    }, "testing the lengthen procedure");

CS17SetupRackette$Rackette.checkExpect(rackette("(define double-all (lambda (alon)\n  (cond\n    ((empty? alon) empty)\n    ((cons? alon) (cons (* 2 (first alon)) (double-all (rest alon)))))))(double-all (cons 54 (cons 64 (cons 755 empty))))"), {
      hd: "(list 108 128 1510)",
      tl: /* [] */0
    }, "testing the double-all procedure");

CS17SetupRackette$Rackette.checkExpect(rackette("(define my-member? (lambda (item alon)\n  (cond\n    ((empty? alon) false)\n    ((cons? alon) (if (equal? (first alon) item)\n                      true\n                      (my-member? item (rest alon))))))) (my-member? 5(cons 1 (cons 2 (cons 5 empty))))"), {
      hd: "true",
      tl: /* [] */0
    }, "testing the my-member? procedure");

CS17SetupRackette$Rackette.checkExpect(rackette("(define my-append (lambda (alon1 alon2)\n  (cond\n    ((and (empty? alon1) (empty? alon2)) empty)\n    ((and (empty? alon1) (cons? alon2)) alon2)\n    ((and (cons? alon1) (empty? alon2)) alon1)\n    ((and (cons? alon1) (cons? alon2)) (cons (first alon1)\n    (my-append (rest alon1)alon2)))))) (my-append (cons 1 (cons 2 empty)) (cons 3 (cons 7 empty)))"), {
      hd: "(list 1 2 3 7)",
      tl: /* [] */0
    }, "testing the my-append procedure");

CS17SetupRackette$Rackette.checkExpect(rackette("(define flipper (lambda (alos)\n  (cond\n    ((empty? alos) empty)\n    ((empty? (rest alos)) alos)\n    ((cons? alos) (cons (first (rest alos))\n                        (cons (first alos)\n                              (flipper (rest (rest alos)))))))))(flipper (cons 1 (cons 2 (cons 3 empty))))"), {
      hd: "(list 2 1 3)",
      tl: /* [] */0
    }, "testing the flipper procedure");

CS17SetupRackette$Rackette.checkExpect(rackette("(define pair-count (lambda (alon1 alon2)\n  (cond\n    ((or (empty? alon1) (empty? alon2)) 0)\n    ((and (cons? alon1) (cons? alon2))\n     (if (equal? (first alon1) (first alon2))\n         (+ 1 (pair-count (rest alon1) (rest alon2)))\n         (pair-count (rest alon1) (rest alon2)))))))(pair-count (cons 1 (cons 5 (cons 56 empty))) (cons 1 (cons 5(cons 2 empty))))"), {
      hd: "2",
      tl: /* [] */0
    }, "testing the pair-count procedure");

CS17SetupRackette$Rackette.checkExpect(rackette("(equal? + +)"), {
      hd: "true",
      tl: /* [] */0
    }, "testing the equal of two + symbols");

CS17SetupRackette$Rackette.checkExpect(rackette("(define add2 (lambda (x y) (+ x y)))"), /* [] */0, "testing a definition");

CS17SetupRackette$Rackette.checkExpect(rackette(" (define map (lambda (proc list) (if (empty? list)\n    empty\n    (cons (proc (first list)) (map proc (rest list))))))(map (lambda (x) (+ x 1)) (cons 1 (cons 2 empty)))"), {
      hd: "(list 2 3)",
      tl: /* [] */0
    }, "testing the map procedure");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(+ 3 false )");
      }), "Error: Second argument was not a number");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(/ true 9)");
      }), "Error: First argument was not a number");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(- 3 9 5)");
      }), "Error: - expects only 2 arguments, but found more than 2");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(* 3)");
      }), "Error: * expects 2 arguments, but found only 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(zero? 5 3)");
      }), "Error: zero? expects only 1 argument, but found more than 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(number? 5 3)");
      }), "Error: number? expects only 1 argument, but found more than 1");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(let ((x 1) (x 4)) (+ x 1))");
      }), "Error: A variable name was defined locally more than once");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(define x 5) (define x 6) x");
      }), "Error: This name was defined previously and cannot be re-defined");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("((lambda (x x) (+ x 1)) 1 2)");
      }), "Error: Found a variable that is used more than once");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(lambda (x))");
      }), "Error: lambda expression did not have correct number of arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("brown");
      }), "Error: This variable/function is not defined");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(I like CS)");
      }), "Error: This variable/function is not defined");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(cond\n  ((zero? 3) 1)\n  ((number? true) 5))");
      }), "Error: All cond expressions resulted in false");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("if (zero? 3) 3 5");
      }), "Error: reserved keyword");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(if (+ 4 5) 3 5)");
      }), "Error: if question result was not true or false");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(+ true false)");
      }), "Error: + expects 2 number arguments, did not find them");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(zero? false)");
      }), "Error: zero? expects a number and didn't find one");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(or 1 2)");
      }), "Error: or expression has incorrect arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("(and 1 2)");
      }), "Error: and expression has incorrect arguments");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("cond");
      }), "Error: reserved keyword");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("define");
      }), "Error: reserved keyword");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("and");
      }), "Error: reserved keyword");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("or");
      }), "Error: reserved keyword");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("if");
      }), "Error: reserved keyword");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("lambda");
      }), "Error: reserved keyword");

CS17SetupRackette$Rackette.checkError((function (param) {
        return rackette("let");
      }), "Error: reserved keyword");

exports.listToString = listToString;
exports.extendEnv = extendEnv;
exports.stringOfValue = stringOfValue;
exports.plus = plus;
exports.minus = minus;
exports.mult = mult;
exports.divide = divide;
exports.remainder = remainder;
exports.equal = equal;
exports.lessThan = lessThan;
exports.greaterThan = greaterThan;
exports.lessThanOrEqualTo = lessThanOrEqualTo;
exports.greaterThanOrEqualTo = greaterThanOrEqualTo;
exports.isEqual = isEqual;
exports.isNumber = isNumber;
exports.isZero = isZero;
exports.cons = cons;
exports.first = first;
exports.rest = rest;
exports.isEmpty = isEmpty;
exports.isCons = isCons;
exports.opposite = opposite;
exports.initialTle = initialTle;
exports.parseExpression = parseExpression;
exports.parseDefinition = parseDefinition;
exports.parsePiece = parsePiece;
exports.parse = parse;
exports.lookup = lookup;
exports.uniqueListP = uniqueListP;
exports.addBindingsToClosure = addBindingsToClosure;
exports.addBinding = addBinding;
exports.$$eval = $$eval;
exports.addDefinition = addDefinition;
exports.$$process = $$process;
exports.rackette = rackette;
/*  Not a pure module */
